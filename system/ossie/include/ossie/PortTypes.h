// This file is generated by omniidl (C++ backend)- omniORB_4_2. Do not edit.
#ifndef __PortTypes_hh__
#define __PortTypes_hh__

#ifndef __CORBA_H_EXTERNAL_GUARD__
#include <omniORB4/CORBA.h>
#endif

#ifndef  USE_stub_in_nt_dll
# define USE_stub_in_nt_dll_NOT_DEFINED_PortTypes
#endif
#ifndef  USE_core_stub_in_nt_dll
# define USE_core_stub_in_nt_dll_NOT_DEFINED_PortTypes
#endif
#ifndef  USE_dyn_stub_in_nt_dll
# define USE_dyn_stub_in_nt_dll_NOT_DEFINED_PortTypes
#endif






#ifdef USE_stub_in_nt_dll
# ifndef USE_core_stub_in_nt_dll
#  define USE_core_stub_in_nt_dll
# endif
# ifndef USE_dyn_stub_in_nt_dll
#  define USE_dyn_stub_in_nt_dll
# endif
#endif

#ifdef _core_attr
# error "A local CPP macro _core_attr has already been defined."
#else
# ifdef  USE_core_stub_in_nt_dll
#  define _core_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _core_attr
# endif
#endif

#ifdef _dyn_attr
# error "A local CPP macro _dyn_attr has already been defined."
#else
# ifdef  USE_dyn_stub_in_nt_dll
#  define _dyn_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _dyn_attr
# endif
#endif



_CORBA_MODULE PortTypes

_CORBA_MODULE_BEG

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_WstringSequence;

  class WstringSequence_var;

  class WstringSequence : public _CORBA_Unbounded_Sequence_WString {
  public:
    typedef WstringSequence_var _var_type;
    inline WstringSequence() {}
    inline WstringSequence(const WstringSequence& _s)
      : _CORBA_Unbounded_Sequence_WString(_s) {}

    inline WstringSequence(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_WString(_max) {}
    inline WstringSequence(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::WChar** _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_WString(_max, _len, _val, _rel) {}

  

    inline WstringSequence& operator = (const WstringSequence& _s) {
      _CORBA_Unbounded_Sequence_WString::operator=(_s);
      return *this;
    }
  };

  class WstringSequence_out;

  class WstringSequence_var {
  public:
    inline WstringSequence_var() : _pd_seq(0) {}
    inline WstringSequence_var(WstringSequence* _s) : _pd_seq(_s) {}
    inline WstringSequence_var(const WstringSequence_var& _s) {
      if (_s._pd_seq)  _pd_seq = new WstringSequence(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~WstringSequence_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline WstringSequence_var& operator = (WstringSequence* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline WstringSequence_var& operator = (const WstringSequence_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new WstringSequence;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline _CORBA_WString_element operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline WstringSequence* operator -> () { return _pd_seq; }
    inline const WstringSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator WstringSequence& () const { return *_pd_seq; }
#else
    inline operator const WstringSequence& () const { return *_pd_seq; }
    inline operator WstringSequence& () { return *_pd_seq; }
#endif
      
    inline const WstringSequence& in() const { return *_pd_seq; }
    inline WstringSequence&       inout()    { return *_pd_seq; }
    inline WstringSequence*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline WstringSequence* _retn() { WstringSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class WstringSequence_out;
    
  private:
    WstringSequence* _pd_seq;
  };

  class WstringSequence_out {
  public:
    inline WstringSequence_out(WstringSequence*& _s) : _data(_s) { _data = 0; }
    inline WstringSequence_out(WstringSequence_var& _s)
      : _data(_s._pd_seq) { _s = (WstringSequence*) 0; }
    inline WstringSequence_out(const WstringSequence_out& _s) : _data(_s._data) {}
    inline WstringSequence_out& operator = (const WstringSequence_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline WstringSequence_out& operator = (WstringSequence* _s) {
      _data = _s;
      return *this;
    }
    inline operator WstringSequence*&()  { return _data; }
    inline WstringSequence*& ptr()       { return _data; }
    inline WstringSequence* operator->() { return _data; }

    inline _CORBA_WString_element operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    WstringSequence*& _data;

  private:
    WstringSequence_out();
    WstringSequence_out& operator=(const WstringSequence_var&);
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_BooleanSequence;

  class BooleanSequence_var;

  class BooleanSequence : public _CORBA_Unbounded_Sequence_Boolean {
  public:
    typedef BooleanSequence_var _var_type;
    inline BooleanSequence() {}
    inline BooleanSequence(const BooleanSequence& _s)
      : _CORBA_Unbounded_Sequence_Boolean(_s) {}

    inline BooleanSequence(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_Boolean(_max) {}
    inline BooleanSequence(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Boolean* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_Boolean(_max, _len, _val, _rel) {}

  

    inline BooleanSequence& operator = (const BooleanSequence& _s) {
      _CORBA_Unbounded_Sequence_Boolean::operator=(_s);
      return *this;
    }
  };

  class BooleanSequence_out;

  class BooleanSequence_var {
  public:
    inline BooleanSequence_var() : _pd_seq(0) {}
    inline BooleanSequence_var(BooleanSequence* _s) : _pd_seq(_s) {}
    inline BooleanSequence_var(const BooleanSequence_var& _s) {
      if (_s._pd_seq)  _pd_seq = new BooleanSequence(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~BooleanSequence_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline BooleanSequence_var& operator = (BooleanSequence* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline BooleanSequence_var& operator = (const BooleanSequence_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new BooleanSequence;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Boolean& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline BooleanSequence* operator -> () { return _pd_seq; }
    inline const BooleanSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator BooleanSequence& () const { return *_pd_seq; }
#else
    inline operator const BooleanSequence& () const { return *_pd_seq; }
    inline operator BooleanSequence& () { return *_pd_seq; }
#endif
      
    inline const BooleanSequence& in() const { return *_pd_seq; }
    inline BooleanSequence&       inout()    { return *_pd_seq; }
    inline BooleanSequence*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline BooleanSequence* _retn() { BooleanSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class BooleanSequence_out;
    
  private:
    BooleanSequence* _pd_seq;
  };

  class BooleanSequence_out {
  public:
    inline BooleanSequence_out(BooleanSequence*& _s) : _data(_s) { _data = 0; }
    inline BooleanSequence_out(BooleanSequence_var& _s)
      : _data(_s._pd_seq) { _s = (BooleanSequence*) 0; }
    inline BooleanSequence_out(const BooleanSequence_out& _s) : _data(_s._data) {}
    inline BooleanSequence_out& operator = (const BooleanSequence_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline BooleanSequence_out& operator = (BooleanSequence* _s) {
      _data = _s;
      return *this;
    }
    inline operator BooleanSequence*&()  { return _data; }
    inline BooleanSequence*& ptr()       { return _data; }
    inline BooleanSequence* operator->() { return _data; }

    inline ::CORBA::Boolean& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    BooleanSequence*& _data;

  private:
    BooleanSequence_out();
    BooleanSequence_out& operator=(const BooleanSequence_var&);
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_CharSequence;

  class CharSequence_var;

  class CharSequence : public _CORBA_Unbounded_Sequence_Char {
  public:
    typedef CharSequence_var _var_type;
    inline CharSequence() {}
    inline CharSequence(const CharSequence& _s)
      : _CORBA_Unbounded_Sequence_Char(_s) {}

    inline CharSequence(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_Char(_max) {}
    inline CharSequence(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Char* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_Char(_max, _len, _val, _rel) {}

  

    inline CharSequence& operator = (const CharSequence& _s) {
      _CORBA_Unbounded_Sequence_Char::operator=(_s);
      return *this;
    }
  };

  class CharSequence_out;

  class CharSequence_var {
  public:
    inline CharSequence_var() : _pd_seq(0) {}
    inline CharSequence_var(CharSequence* _s) : _pd_seq(_s) {}
    inline CharSequence_var(const CharSequence_var& _s) {
      if (_s._pd_seq)  _pd_seq = new CharSequence(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~CharSequence_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline CharSequence_var& operator = (CharSequence* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline CharSequence_var& operator = (const CharSequence_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new CharSequence;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Char& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline CharSequence* operator -> () { return _pd_seq; }
    inline const CharSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator CharSequence& () const { return *_pd_seq; }
#else
    inline operator const CharSequence& () const { return *_pd_seq; }
    inline operator CharSequence& () { return *_pd_seq; }
#endif
      
    inline const CharSequence& in() const { return *_pd_seq; }
    inline CharSequence&       inout()    { return *_pd_seq; }
    inline CharSequence*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline CharSequence* _retn() { CharSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class CharSequence_out;
    
  private:
    CharSequence* _pd_seq;
  };

  class CharSequence_out {
  public:
    inline CharSequence_out(CharSequence*& _s) : _data(_s) { _data = 0; }
    inline CharSequence_out(CharSequence_var& _s)
      : _data(_s._pd_seq) { _s = (CharSequence*) 0; }
    inline CharSequence_out(const CharSequence_out& _s) : _data(_s._data) {}
    inline CharSequence_out& operator = (const CharSequence_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline CharSequence_out& operator = (CharSequence* _s) {
      _data = _s;
      return *this;
    }
    inline operator CharSequence*&()  { return _data; }
    inline CharSequence*& ptr()       { return _data; }
    inline CharSequence* operator->() { return _data; }

    inline ::CORBA::Char& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    CharSequence*& _data;

  private:
    CharSequence_out();
    CharSequence_out& operator=(const CharSequence_var&);
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_DoubleSequence;

  class DoubleSequence_var;

  class DoubleSequence : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 >  {
  public:
    typedef DoubleSequence_var _var_type;
    inline DoubleSequence() {}
    inline DoubleSequence(const DoubleSequence& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > (_s) {}

    inline DoubleSequence(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > (_max) {}
    inline DoubleSequence(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Double* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > (_max, _len, _val, _rel) {}

  

    inline DoubleSequence& operator = (const DoubleSequence& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > ::operator=(_s);
      return *this;
    }
  };

  class DoubleSequence_out;

  class DoubleSequence_var {
  public:
    inline DoubleSequence_var() : _pd_seq(0) {}
    inline DoubleSequence_var(DoubleSequence* _s) : _pd_seq(_s) {}
    inline DoubleSequence_var(const DoubleSequence_var& _s) {
      if (_s._pd_seq)  _pd_seq = new DoubleSequence(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~DoubleSequence_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline DoubleSequence_var& operator = (DoubleSequence* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline DoubleSequence_var& operator = (const DoubleSequence_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new DoubleSequence;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Double& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline DoubleSequence* operator -> () { return _pd_seq; }
    inline const DoubleSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator DoubleSequence& () const { return *_pd_seq; }
#else
    inline operator const DoubleSequence& () const { return *_pd_seq; }
    inline operator DoubleSequence& () { return *_pd_seq; }
#endif
      
    inline const DoubleSequence& in() const { return *_pd_seq; }
    inline DoubleSequence&       inout()    { return *_pd_seq; }
    inline DoubleSequence*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline DoubleSequence* _retn() { DoubleSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class DoubleSequence_out;
    
  private:
    DoubleSequence* _pd_seq;
  };

  class DoubleSequence_out {
  public:
    inline DoubleSequence_out(DoubleSequence*& _s) : _data(_s) { _data = 0; }
    inline DoubleSequence_out(DoubleSequence_var& _s)
      : _data(_s._pd_seq) { _s = (DoubleSequence*) 0; }
    inline DoubleSequence_out(const DoubleSequence_out& _s) : _data(_s._data) {}
    inline DoubleSequence_out& operator = (const DoubleSequence_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline DoubleSequence_out& operator = (DoubleSequence* _s) {
      _data = _s;
      return *this;
    }
    inline operator DoubleSequence*&()  { return _data; }
    inline DoubleSequence*& ptr()       { return _data; }
    inline DoubleSequence* operator->() { return _data; }

    inline ::CORBA::Double& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    DoubleSequence*& _data;

  private:
    DoubleSequence_out();
    DoubleSequence_out& operator=(const DoubleSequence_var&);
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_LongSequence;

  class LongSequence_var;

  class LongSequence : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 >  {
  public:
    typedef LongSequence_var _var_type;
    inline LongSequence() {}
    inline LongSequence(const LongSequence& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_s) {}

    inline LongSequence(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max) {}
    inline LongSequence(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Long* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline LongSequence& operator = (const LongSequence& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Long, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class LongSequence_out;

  class LongSequence_var {
  public:
    inline LongSequence_var() : _pd_seq(0) {}
    inline LongSequence_var(LongSequence* _s) : _pd_seq(_s) {}
    inline LongSequence_var(const LongSequence_var& _s) {
      if (_s._pd_seq)  _pd_seq = new LongSequence(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~LongSequence_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline LongSequence_var& operator = (LongSequence* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline LongSequence_var& operator = (const LongSequence_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new LongSequence;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Long& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline LongSequence* operator -> () { return _pd_seq; }
    inline const LongSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator LongSequence& () const { return *_pd_seq; }
#else
    inline operator const LongSequence& () const { return *_pd_seq; }
    inline operator LongSequence& () { return *_pd_seq; }
#endif
      
    inline const LongSequence& in() const { return *_pd_seq; }
    inline LongSequence&       inout()    { return *_pd_seq; }
    inline LongSequence*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline LongSequence* _retn() { LongSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class LongSequence_out;
    
  private:
    LongSequence* _pd_seq;
  };

  class LongSequence_out {
  public:
    inline LongSequence_out(LongSequence*& _s) : _data(_s) { _data = 0; }
    inline LongSequence_out(LongSequence_var& _s)
      : _data(_s._pd_seq) { _s = (LongSequence*) 0; }
    inline LongSequence_out(const LongSequence_out& _s) : _data(_s._data) {}
    inline LongSequence_out& operator = (const LongSequence_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline LongSequence_out& operator = (LongSequence* _s) {
      _data = _s;
      return *this;
    }
    inline operator LongSequence*&()  { return _data; }
    inline LongSequence*& ptr()       { return _data; }
    inline LongSequence* operator->() { return _data; }

    inline ::CORBA::Long& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    LongSequence*& _data;

  private:
    LongSequence_out();
    LongSequence_out& operator=(const LongSequence_var&);
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ShortSequence;

  class ShortSequence_var;

  class ShortSequence : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Short, 2, 2 >  {
  public:
    typedef ShortSequence_var _var_type;
    inline ShortSequence() {}
    inline ShortSequence(const ShortSequence& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Short, 2, 2 > (_s) {}

    inline ShortSequence(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Short, 2, 2 > (_max) {}
    inline ShortSequence(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Short* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Short, 2, 2 > (_max, _len, _val, _rel) {}

  

    inline ShortSequence& operator = (const ShortSequence& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Short, 2, 2 > ::operator=(_s);
      return *this;
    }
  };

  class ShortSequence_out;

  class ShortSequence_var {
  public:
    inline ShortSequence_var() : _pd_seq(0) {}
    inline ShortSequence_var(ShortSequence* _s) : _pd_seq(_s) {}
    inline ShortSequence_var(const ShortSequence_var& _s) {
      if (_s._pd_seq)  _pd_seq = new ShortSequence(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~ShortSequence_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline ShortSequence_var& operator = (ShortSequence* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline ShortSequence_var& operator = (const ShortSequence_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new ShortSequence;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Short& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline ShortSequence* operator -> () { return _pd_seq; }
    inline const ShortSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator ShortSequence& () const { return *_pd_seq; }
#else
    inline operator const ShortSequence& () const { return *_pd_seq; }
    inline operator ShortSequence& () { return *_pd_seq; }
#endif
      
    inline const ShortSequence& in() const { return *_pd_seq; }
    inline ShortSequence&       inout()    { return *_pd_seq; }
    inline ShortSequence*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline ShortSequence* _retn() { ShortSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class ShortSequence_out;
    
  private:
    ShortSequence* _pd_seq;
  };

  class ShortSequence_out {
  public:
    inline ShortSequence_out(ShortSequence*& _s) : _data(_s) { _data = 0; }
    inline ShortSequence_out(ShortSequence_var& _s)
      : _data(_s._pd_seq) { _s = (ShortSequence*) 0; }
    inline ShortSequence_out(const ShortSequence_out& _s) : _data(_s._data) {}
    inline ShortSequence_out& operator = (const ShortSequence_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline ShortSequence_out& operator = (ShortSequence* _s) {
      _data = _s;
      return *this;
    }
    inline operator ShortSequence*&()  { return _data; }
    inline ShortSequence*& ptr()       { return _data; }
    inline ShortSequence* operator->() { return _data; }

    inline ::CORBA::Short& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    ShortSequence*& _data;

  private:
    ShortSequence_out();
    ShortSequence_out& operator=(const ShortSequence_var&);
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_UlongLongSequence;

  class UlongLongSequence_var;

  class UlongLongSequence : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::ULongLong, 8, 8 >  {
  public:
    typedef UlongLongSequence_var _var_type;
    inline UlongLongSequence() {}
    inline UlongLongSequence(const UlongLongSequence& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::ULongLong, 8, 8 > (_s) {}

    inline UlongLongSequence(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::ULongLong, 8, 8 > (_max) {}
    inline UlongLongSequence(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::ULongLong* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::ULongLong, 8, 8 > (_max, _len, _val, _rel) {}

  

    inline UlongLongSequence& operator = (const UlongLongSequence& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::ULongLong, 8, 8 > ::operator=(_s);
      return *this;
    }
  };

  class UlongLongSequence_out;

  class UlongLongSequence_var {
  public:
    inline UlongLongSequence_var() : _pd_seq(0) {}
    inline UlongLongSequence_var(UlongLongSequence* _s) : _pd_seq(_s) {}
    inline UlongLongSequence_var(const UlongLongSequence_var& _s) {
      if (_s._pd_seq)  _pd_seq = new UlongLongSequence(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~UlongLongSequence_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline UlongLongSequence_var& operator = (UlongLongSequence* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline UlongLongSequence_var& operator = (const UlongLongSequence_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new UlongLongSequence;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::ULongLong& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline UlongLongSequence* operator -> () { return _pd_seq; }
    inline const UlongLongSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator UlongLongSequence& () const { return *_pd_seq; }
#else
    inline operator const UlongLongSequence& () const { return *_pd_seq; }
    inline operator UlongLongSequence& () { return *_pd_seq; }
#endif
      
    inline const UlongLongSequence& in() const { return *_pd_seq; }
    inline UlongLongSequence&       inout()    { return *_pd_seq; }
    inline UlongLongSequence*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline UlongLongSequence* _retn() { UlongLongSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class UlongLongSequence_out;
    
  private:
    UlongLongSequence* _pd_seq;
  };

  class UlongLongSequence_out {
  public:
    inline UlongLongSequence_out(UlongLongSequence*& _s) : _data(_s) { _data = 0; }
    inline UlongLongSequence_out(UlongLongSequence_var& _s)
      : _data(_s._pd_seq) { _s = (UlongLongSequence*) 0; }
    inline UlongLongSequence_out(const UlongLongSequence_out& _s) : _data(_s._data) {}
    inline UlongLongSequence_out& operator = (const UlongLongSequence_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline UlongLongSequence_out& operator = (UlongLongSequence* _s) {
      _data = _s;
      return *this;
    }
    inline operator UlongLongSequence*&()  { return _data; }
    inline UlongLongSequence*& ptr()       { return _data; }
    inline UlongLongSequence* operator->() { return _data; }

    inline ::CORBA::ULongLong& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    UlongLongSequence*& _data;

  private:
    UlongLongSequence_out();
    UlongLongSequence_out& operator=(const UlongLongSequence_var&);
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_UlongSequence;

  class UlongSequence_var;

  class UlongSequence : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::ULong, 4, 4 >  {
  public:
    typedef UlongSequence_var _var_type;
    inline UlongSequence() {}
    inline UlongSequence(const UlongSequence& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::ULong, 4, 4 > (_s) {}

    inline UlongSequence(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::ULong, 4, 4 > (_max) {}
    inline UlongSequence(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::ULong* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::ULong, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline UlongSequence& operator = (const UlongSequence& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::ULong, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class UlongSequence_out;

  class UlongSequence_var {
  public:
    inline UlongSequence_var() : _pd_seq(0) {}
    inline UlongSequence_var(UlongSequence* _s) : _pd_seq(_s) {}
    inline UlongSequence_var(const UlongSequence_var& _s) {
      if (_s._pd_seq)  _pd_seq = new UlongSequence(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~UlongSequence_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline UlongSequence_var& operator = (UlongSequence* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline UlongSequence_var& operator = (const UlongSequence_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new UlongSequence;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::ULong& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline UlongSequence* operator -> () { return _pd_seq; }
    inline const UlongSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator UlongSequence& () const { return *_pd_seq; }
#else
    inline operator const UlongSequence& () const { return *_pd_seq; }
    inline operator UlongSequence& () { return *_pd_seq; }
#endif
      
    inline const UlongSequence& in() const { return *_pd_seq; }
    inline UlongSequence&       inout()    { return *_pd_seq; }
    inline UlongSequence*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline UlongSequence* _retn() { UlongSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class UlongSequence_out;
    
  private:
    UlongSequence* _pd_seq;
  };

  class UlongSequence_out {
  public:
    inline UlongSequence_out(UlongSequence*& _s) : _data(_s) { _data = 0; }
    inline UlongSequence_out(UlongSequence_var& _s)
      : _data(_s._pd_seq) { _s = (UlongSequence*) 0; }
    inline UlongSequence_out(const UlongSequence_out& _s) : _data(_s._data) {}
    inline UlongSequence_out& operator = (const UlongSequence_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline UlongSequence_out& operator = (UlongSequence* _s) {
      _data = _s;
      return *this;
    }
    inline operator UlongSequence*&()  { return _data; }
    inline UlongSequence*& ptr()       { return _data; }
    inline UlongSequence* operator->() { return _data; }

    inline ::CORBA::ULong& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    UlongSequence*& _data;

  private:
    UlongSequence_out();
    UlongSequence_out& operator=(const UlongSequence_var&);
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_UshortSequence;

  class UshortSequence_var;

  class UshortSequence : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::UShort, 2, 2 >  {
  public:
    typedef UshortSequence_var _var_type;
    inline UshortSequence() {}
    inline UshortSequence(const UshortSequence& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::UShort, 2, 2 > (_s) {}

    inline UshortSequence(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::UShort, 2, 2 > (_max) {}
    inline UshortSequence(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::UShort* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::UShort, 2, 2 > (_max, _len, _val, _rel) {}

  

    inline UshortSequence& operator = (const UshortSequence& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::UShort, 2, 2 > ::operator=(_s);
      return *this;
    }
  };

  class UshortSequence_out;

  class UshortSequence_var {
  public:
    inline UshortSequence_var() : _pd_seq(0) {}
    inline UshortSequence_var(UshortSequence* _s) : _pd_seq(_s) {}
    inline UshortSequence_var(const UshortSequence_var& _s) {
      if (_s._pd_seq)  _pd_seq = new UshortSequence(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~UshortSequence_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline UshortSequence_var& operator = (UshortSequence* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline UshortSequence_var& operator = (const UshortSequence_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new UshortSequence;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::UShort& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline UshortSequence* operator -> () { return _pd_seq; }
    inline const UshortSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator UshortSequence& () const { return *_pd_seq; }
#else
    inline operator const UshortSequence& () const { return *_pd_seq; }
    inline operator UshortSequence& () { return *_pd_seq; }
#endif
      
    inline const UshortSequence& in() const { return *_pd_seq; }
    inline UshortSequence&       inout()    { return *_pd_seq; }
    inline UshortSequence*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline UshortSequence* _retn() { UshortSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class UshortSequence_out;
    
  private:
    UshortSequence* _pd_seq;
  };

  class UshortSequence_out {
  public:
    inline UshortSequence_out(UshortSequence*& _s) : _data(_s) { _data = 0; }
    inline UshortSequence_out(UshortSequence_var& _s)
      : _data(_s._pd_seq) { _s = (UshortSequence*) 0; }
    inline UshortSequence_out(const UshortSequence_out& _s) : _data(_s._data) {}
    inline UshortSequence_out& operator = (const UshortSequence_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline UshortSequence_out& operator = (UshortSequence* _s) {
      _data = _s;
      return *this;
    }
    inline operator UshortSequence*&()  { return _data; }
    inline UshortSequence*& ptr()       { return _data; }
    inline UshortSequence* operator->() { return _data; }

    inline ::CORBA::UShort& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    UshortSequence*& _data;

  private:
    UshortSequence_out();
    UshortSequence_out& operator=(const UshortSequence_var&);
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_WcharSequence;

  class WcharSequence_var;

  class WcharSequence : public _CORBA_Unbounded_Sequence_WChar {
  public:
    typedef WcharSequence_var _var_type;
    inline WcharSequence() {}
    inline WcharSequence(const WcharSequence& _s)
      : _CORBA_Unbounded_Sequence_WChar(_s) {}

    inline WcharSequence(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_WChar(_max) {}
    inline WcharSequence(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::WChar* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_WChar(_max, _len, _val, _rel) {}

  

    inline WcharSequence& operator = (const WcharSequence& _s) {
      _CORBA_Unbounded_Sequence_WChar::operator=(_s);
      return *this;
    }
  };

  class WcharSequence_out;

  class WcharSequence_var {
  public:
    inline WcharSequence_var() : _pd_seq(0) {}
    inline WcharSequence_var(WcharSequence* _s) : _pd_seq(_s) {}
    inline WcharSequence_var(const WcharSequence_var& _s) {
      if (_s._pd_seq)  _pd_seq = new WcharSequence(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~WcharSequence_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline WcharSequence_var& operator = (WcharSequence* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline WcharSequence_var& operator = (const WcharSequence_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new WcharSequence;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::WChar& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline WcharSequence* operator -> () { return _pd_seq; }
    inline const WcharSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator WcharSequence& () const { return *_pd_seq; }
#else
    inline operator const WcharSequence& () const { return *_pd_seq; }
    inline operator WcharSequence& () { return *_pd_seq; }
#endif
      
    inline const WcharSequence& in() const { return *_pd_seq; }
    inline WcharSequence&       inout()    { return *_pd_seq; }
    inline WcharSequence*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline WcharSequence* _retn() { WcharSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class WcharSequence_out;
    
  private:
    WcharSequence* _pd_seq;
  };

  class WcharSequence_out {
  public:
    inline WcharSequence_out(WcharSequence*& _s) : _data(_s) { _data = 0; }
    inline WcharSequence_out(WcharSequence_var& _s)
      : _data(_s._pd_seq) { _s = (WcharSequence*) 0; }
    inline WcharSequence_out(const WcharSequence_out& _s) : _data(_s._data) {}
    inline WcharSequence_out& operator = (const WcharSequence_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline WcharSequence_out& operator = (WcharSequence* _s) {
      _data = _s;
      return *this;
    }
    inline operator WcharSequence*&()  { return _data; }
    inline WcharSequence*& ptr()       { return _data; }
    inline WcharSequence* operator->() { return _data; }

    inline ::CORBA::WChar& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    WcharSequence*& _data;

  private:
    WcharSequence_out();
    WcharSequence_out& operator=(const WcharSequence_var&);
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_FloatSequence;

  class FloatSequence_var;

  class FloatSequence : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Float, 4, 4 >  {
  public:
    typedef FloatSequence_var _var_type;
    inline FloatSequence() {}
    inline FloatSequence(const FloatSequence& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Float, 4, 4 > (_s) {}

    inline FloatSequence(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Float, 4, 4 > (_max) {}
    inline FloatSequence(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Float* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Float, 4, 4 > (_max, _len, _val, _rel) {}

  

    inline FloatSequence& operator = (const FloatSequence& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Float, 4, 4 > ::operator=(_s);
      return *this;
    }
  };

  class FloatSequence_out;

  class FloatSequence_var {
  public:
    inline FloatSequence_var() : _pd_seq(0) {}
    inline FloatSequence_var(FloatSequence* _s) : _pd_seq(_s) {}
    inline FloatSequence_var(const FloatSequence_var& _s) {
      if (_s._pd_seq)  _pd_seq = new FloatSequence(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~FloatSequence_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline FloatSequence_var& operator = (FloatSequence* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline FloatSequence_var& operator = (const FloatSequence_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new FloatSequence;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Float& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline FloatSequence* operator -> () { return _pd_seq; }
    inline const FloatSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator FloatSequence& () const { return *_pd_seq; }
#else
    inline operator const FloatSequence& () const { return *_pd_seq; }
    inline operator FloatSequence& () { return *_pd_seq; }
#endif
      
    inline const FloatSequence& in() const { return *_pd_seq; }
    inline FloatSequence&       inout()    { return *_pd_seq; }
    inline FloatSequence*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline FloatSequence* _retn() { FloatSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class FloatSequence_out;
    
  private:
    FloatSequence* _pd_seq;
  };

  class FloatSequence_out {
  public:
    inline FloatSequence_out(FloatSequence*& _s) : _data(_s) { _data = 0; }
    inline FloatSequence_out(FloatSequence_var& _s)
      : _data(_s._pd_seq) { _s = (FloatSequence*) 0; }
    inline FloatSequence_out(const FloatSequence_out& _s) : _data(_s._data) {}
    inline FloatSequence_out& operator = (const FloatSequence_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline FloatSequence_out& operator = (FloatSequence* _s) {
      _data = _s;
      return *this;
    }
    inline operator FloatSequence*&()  { return _data; }
    inline FloatSequence*& ptr()       { return _data; }
    inline FloatSequence* operator->() { return _data; }

    inline ::CORBA::Float& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    FloatSequence*& _data;

  private:
    FloatSequence_out();
    FloatSequence_out& operator=(const FloatSequence_var&);
  };

_CORBA_MODULE_END



_CORBA_MODULE POA_PortTypes
_CORBA_MODULE_BEG

_CORBA_MODULE_END



_CORBA_MODULE OBV_PortTypes
_CORBA_MODULE_BEG

_CORBA_MODULE_END





#undef _core_attr
#undef _dyn_attr

void operator<<=(::CORBA::Any& _a, const PortTypes::WstringSequence& _s);
void operator<<=(::CORBA::Any& _a, PortTypes::WstringSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, PortTypes::WstringSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const PortTypes::WstringSequence*& _sp);

void operator<<=(::CORBA::Any& _a, const PortTypes::BooleanSequence& _s);
void operator<<=(::CORBA::Any& _a, PortTypes::BooleanSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, PortTypes::BooleanSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const PortTypes::BooleanSequence*& _sp);

void operator<<=(::CORBA::Any& _a, const PortTypes::CharSequence& _s);
void operator<<=(::CORBA::Any& _a, PortTypes::CharSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, PortTypes::CharSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const PortTypes::CharSequence*& _sp);

void operator<<=(::CORBA::Any& _a, const PortTypes::DoubleSequence& _s);
void operator<<=(::CORBA::Any& _a, PortTypes::DoubleSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, PortTypes::DoubleSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const PortTypes::DoubleSequence*& _sp);

void operator<<=(::CORBA::Any& _a, const PortTypes::LongSequence& _s);
void operator<<=(::CORBA::Any& _a, PortTypes::LongSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, PortTypes::LongSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const PortTypes::LongSequence*& _sp);

void operator<<=(::CORBA::Any& _a, const PortTypes::ShortSequence& _s);
void operator<<=(::CORBA::Any& _a, PortTypes::ShortSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, PortTypes::ShortSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const PortTypes::ShortSequence*& _sp);

void operator<<=(::CORBA::Any& _a, const PortTypes::UlongLongSequence& _s);
void operator<<=(::CORBA::Any& _a, PortTypes::UlongLongSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, PortTypes::UlongLongSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const PortTypes::UlongLongSequence*& _sp);

void operator<<=(::CORBA::Any& _a, const PortTypes::UlongSequence& _s);
void operator<<=(::CORBA::Any& _a, PortTypes::UlongSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, PortTypes::UlongSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const PortTypes::UlongSequence*& _sp);

void operator<<=(::CORBA::Any& _a, const PortTypes::UshortSequence& _s);
void operator<<=(::CORBA::Any& _a, PortTypes::UshortSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, PortTypes::UshortSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const PortTypes::UshortSequence*& _sp);

void operator<<=(::CORBA::Any& _a, const PortTypes::WcharSequence& _s);
void operator<<=(::CORBA::Any& _a, PortTypes::WcharSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, PortTypes::WcharSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const PortTypes::WcharSequence*& _sp);

void operator<<=(::CORBA::Any& _a, const PortTypes::FloatSequence& _s);
void operator<<=(::CORBA::Any& _a, PortTypes::FloatSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, PortTypes::FloatSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const PortTypes::FloatSequence*& _sp);





#ifdef   USE_stub_in_nt_dll_NOT_DEFINED_PortTypes
# undef  USE_stub_in_nt_dll
# undef  USE_stub_in_nt_dll_NOT_DEFINED_PortTypes
#endif
#ifdef   USE_core_stub_in_nt_dll_NOT_DEFINED_PortTypes
# undef  USE_core_stub_in_nt_dll
# undef  USE_core_stub_in_nt_dll_NOT_DEFINED_PortTypes
#endif
#ifdef   USE_dyn_stub_in_nt_dll_NOT_DEFINED_PortTypes
# undef  USE_dyn_stub_in_nt_dll
# undef  USE_dyn_stub_in_nt_dll_NOT_DEFINED_PortTypes
#endif

#endif  // __PortTypes_hh__

