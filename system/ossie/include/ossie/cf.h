// This file is generated by omniidl (C++ backend)- omniORB_4_2. Do not edit.
#ifndef __cf_hh__
#define __cf_hh__

#ifndef __CORBA_H_EXTERNAL_GUARD__
#include <omniORB4/CORBA.h>
#endif

#ifndef  USE_stub_in_nt_dll
# define USE_stub_in_nt_dll_NOT_DEFINED_cf
#endif
#ifndef  USE_core_stub_in_nt_dll
# define USE_core_stub_in_nt_dll_NOT_DEFINED_cf
#endif
#ifndef  USE_dyn_stub_in_nt_dll
# define USE_dyn_stub_in_nt_dll_NOT_DEFINED_cf
#endif






#ifdef USE_stub_in_nt_dll
# ifndef USE_core_stub_in_nt_dll
#  define USE_core_stub_in_nt_dll
# endif
# ifndef USE_dyn_stub_in_nt_dll
#  define USE_dyn_stub_in_nt_dll
# endif
#endif

#ifdef _core_attr
# error "A local CPP macro _core_attr has already been defined."
#else
# ifdef  USE_core_stub_in_nt_dll
#  define _core_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _core_attr
# endif
#endif

#ifdef _dyn_attr
# error "A local CPP macro _dyn_attr has already been defined."
#else
# ifdef  USE_dyn_stub_in_nt_dll
#  define _dyn_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _dyn_attr
# endif
#endif



_CORBA_MODULE CF

_CORBA_MODULE_BEG

#ifndef __CF_mFile__
#define __CF_mFile__
  class File;
  class _objref_File;
  class _impl_File;
  
  typedef _objref_File* File_ptr;
  typedef File_ptr FileRef;

  class File_Helper {
  public:
    typedef File_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_File, File_Helper> File_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_File,File_Helper > File_out;

#endif

#ifndef __CF_mResource__
#define __CF_mResource__
  class Resource;
  class _objref_Resource;
  class _impl_Resource;
  
  typedef _objref_Resource* Resource_ptr;
  typedef Resource_ptr ResourceRef;

  class Resource_Helper {
  public:
    typedef Resource_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_Resource, Resource_Helper> Resource_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_Resource,Resource_Helper > Resource_out;

#endif

#ifndef __CF_mApplication__
#define __CF_mApplication__
  class Application;
  class _objref_Application;
  class _impl_Application;
  
  typedef _objref_Application* Application_ptr;
  typedef Application_ptr ApplicationRef;

  class Application_Helper {
  public:
    typedef Application_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_Application, Application_Helper> Application_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_Application,Application_Helper > Application_out;

#endif

#ifndef __CF_mDevice__
#define __CF_mDevice__
  class Device;
  class _objref_Device;
  class _impl_Device;
  
  typedef _objref_Device* Device_ptr;
  typedef Device_ptr DeviceRef;

  class Device_Helper {
  public:
    typedef Device_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_Device, Device_Helper> Device_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_Device,Device_Helper > Device_out;

#endif

#ifndef __CF_mApplicationFactory__
#define __CF_mApplicationFactory__
  class ApplicationFactory;
  class _objref_ApplicationFactory;
  class _impl_ApplicationFactory;
  
  typedef _objref_ApplicationFactory* ApplicationFactory_ptr;
  typedef ApplicationFactory_ptr ApplicationFactoryRef;

  class ApplicationFactory_Helper {
  public:
    typedef ApplicationFactory_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_ApplicationFactory, ApplicationFactory_Helper> ApplicationFactory_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_ApplicationFactory,ApplicationFactory_Helper > ApplicationFactory_out;

#endif

#ifndef __CF_mDeviceManager__
#define __CF_mDeviceManager__
  class DeviceManager;
  class _objref_DeviceManager;
  class _impl_DeviceManager;
  
  typedef _objref_DeviceManager* DeviceManager_ptr;
  typedef DeviceManager_ptr DeviceManagerRef;

  class DeviceManager_Helper {
  public:
    typedef DeviceManager_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_DeviceManager, DeviceManager_Helper> DeviceManager_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_DeviceManager,DeviceManager_Helper > DeviceManager_out;

#endif

  struct DataType {
    typedef _CORBA_ConstrType_Variable_Var<DataType> _var_type;

    
    ::CORBA::String_member id;

    ::CORBA::Any value;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef DataType::_var_type DataType_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< DataType,DataType_var > DataType_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_DataType;

  class InvalidProfile : public ::CORBA::UserException {
  public:
    
    

    inline InvalidProfile() {
      pd_insertToAnyFn    = insertToAnyFn;
      pd_insertToAnyFnNCP = insertToAnyFnNCP;
    }
    InvalidProfile(const InvalidProfile&);
    
    InvalidProfile& operator=(const InvalidProfile&);
    virtual ~InvalidProfile();
    virtual void _raise() const;
    static InvalidProfile* _downcast(::CORBA::Exception*);
    static const InvalidProfile* _downcast(const ::CORBA::Exception*);
    static inline InvalidProfile* _narrow(::CORBA::Exception* _e) {
      return _downcast(_e);
    }
    
    inline void operator>>=(cdrStream&) const { }
    inline void operator<<=(cdrStream&) { }

    static _core_attr insertExceptionToAny    insertToAnyFn;
    static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

    virtual ::CORBA::Exception* _NP_duplicate() const;

    static _core_attr const char* _PD_repoId;
    static _core_attr const char* _PD_typeId;

  private:
    virtual const char* _NP_typeId() const;
    virtual const char* _NP_repoId(int*) const;
    virtual void _NP_marshal(cdrStream&) const;
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_InvalidProfile;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Properties;

  class Properties_var;

  class Properties : public _CORBA_Unbounded_Sequence< DataType >  {
  public:
    typedef Properties_var _var_type;
    inline Properties() {}
    inline Properties(const Properties& _s)
      : _CORBA_Unbounded_Sequence< DataType > (_s) {}

    inline Properties(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< DataType > (_max) {}
    inline Properties(_CORBA_ULong _max, _CORBA_ULong _len, DataType* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< DataType > (_max, _len, _val, _rel) {}

  

    inline Properties& operator = (const Properties& _s) {
      _CORBA_Unbounded_Sequence< DataType > ::operator=(_s);
      return *this;
    }
  };

  class Properties_out;

  class Properties_var {
  public:
    inline Properties_var() : _pd_seq(0) {}
    inline Properties_var(Properties* _s) : _pd_seq(_s) {}
    inline Properties_var(const Properties_var& _s) {
      if (_s._pd_seq)  _pd_seq = new Properties(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~Properties_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline Properties_var& operator = (Properties* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline Properties_var& operator = (const Properties_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new Properties;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline DataType& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline Properties* operator -> () { return _pd_seq; }
    inline const Properties* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator Properties& () const { return *_pd_seq; }
#else
    inline operator const Properties& () const { return *_pd_seq; }
    inline operator Properties& () { return *_pd_seq; }
#endif
      
    inline const Properties& in() const { return *_pd_seq; }
    inline Properties&       inout()    { return *_pd_seq; }
    inline Properties*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline Properties* _retn() { Properties* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class Properties_out;
    
  private:
    Properties* _pd_seq;
  };

  class Properties_out {
  public:
    inline Properties_out(Properties*& _s) : _data(_s) { _data = 0; }
    inline Properties_out(Properties_var& _s)
      : _data(_s._pd_seq) { _s = (Properties*) 0; }
    inline Properties_out(const Properties_out& _s) : _data(_s._data) {}
    inline Properties_out& operator = (const Properties_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline Properties_out& operator = (Properties* _s) {
      _data = _s;
      return *this;
    }
    inline operator Properties*&()  { return _data; }
    inline Properties*& ptr()       { return _data; }
    inline Properties* operator->() { return _data; }

    inline DataType& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    Properties*& _data;

  private:
    Properties_out();
    Properties_out& operator=(const Properties_var&);
  };

  class InvalidObjectReference : public ::CORBA::UserException {
  public:
    
    ::CORBA::String_member msg;

  

    inline InvalidObjectReference() {
      pd_insertToAnyFn    = insertToAnyFn;
      pd_insertToAnyFnNCP = insertToAnyFnNCP;
    }
    InvalidObjectReference(const InvalidObjectReference&);
    InvalidObjectReference(const char* i_msg);
    InvalidObjectReference& operator=(const InvalidObjectReference&);
    virtual ~InvalidObjectReference();
    virtual void _raise() const;
    static InvalidObjectReference* _downcast(::CORBA::Exception*);
    static const InvalidObjectReference* _downcast(const ::CORBA::Exception*);
    static inline InvalidObjectReference* _narrow(::CORBA::Exception* _e) {
      return _downcast(_e);
    }
    
    void operator>>=(cdrStream&) const ;
    void operator<<=(cdrStream&) ;

    static _core_attr insertExceptionToAny    insertToAnyFn;
    static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

    virtual ::CORBA::Exception* _NP_duplicate() const;

    static _core_attr const char* _PD_repoId;
    static _core_attr const char* _PD_typeId;

  private:
    virtual const char* _NP_typeId() const;
    virtual const char* _NP_repoId(int*) const;
    virtual void _NP_marshal(cdrStream&) const;
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_InvalidObjectReference;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_OctetSequence;

  class OctetSequence_var;

  class OctetSequence : public _CORBA_Unbounded_Sequence_Octet {
  public:
    typedef OctetSequence_var _var_type;
    inline OctetSequence() {}
    inline OctetSequence(const OctetSequence& _s)
      : _CORBA_Unbounded_Sequence_Octet(_s) {}

    inline OctetSequence(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_Octet(_max) {}
    inline OctetSequence(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Octet* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_Octet(_max, _len, _val, _rel) {}

  

    inline OctetSequence& operator = (const OctetSequence& _s) {
      _CORBA_Unbounded_Sequence_Octet::operator=(_s);
      return *this;
    }
  };

  class OctetSequence_out;

  class OctetSequence_var {
  public:
    inline OctetSequence_var() : _pd_seq(0) {}
    inline OctetSequence_var(OctetSequence* _s) : _pd_seq(_s) {}
    inline OctetSequence_var(const OctetSequence_var& _s) {
      if (_s._pd_seq)  _pd_seq = new OctetSequence(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~OctetSequence_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline OctetSequence_var& operator = (OctetSequence* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline OctetSequence_var& operator = (const OctetSequence_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new OctetSequence;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Octet& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline OctetSequence* operator -> () { return _pd_seq; }
    inline const OctetSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator OctetSequence& () const { return *_pd_seq; }
#else
    inline operator const OctetSequence& () const { return *_pd_seq; }
    inline operator OctetSequence& () { return *_pd_seq; }
#endif
      
    inline const OctetSequence& in() const { return *_pd_seq; }
    inline OctetSequence&       inout()    { return *_pd_seq; }
    inline OctetSequence*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline OctetSequence* _retn() { OctetSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class OctetSequence_out;
    
  private:
    OctetSequence* _pd_seq;
  };

  class OctetSequence_out {
  public:
    inline OctetSequence_out(OctetSequence*& _s) : _data(_s) { _data = 0; }
    inline OctetSequence_out(OctetSequence_var& _s)
      : _data(_s._pd_seq) { _s = (OctetSequence*) 0; }
    inline OctetSequence_out(const OctetSequence_out& _s) : _data(_s._data) {}
    inline OctetSequence_out& operator = (const OctetSequence_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline OctetSequence_out& operator = (OctetSequence* _s) {
      _data = _s;
      return *this;
    }
    inline operator OctetSequence*&()  { return _data; }
    inline OctetSequence*& ptr()       { return _data; }
    inline OctetSequence* operator->() { return _data; }

    inline ::CORBA::Octet& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    OctetSequence*& _data;

  private:
    OctetSequence_out();
    OctetSequence_out& operator=(const OctetSequence_var&);
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_StringSequence;

  class StringSequence_var;

  class StringSequence : public _CORBA_Unbounded_Sequence_String {
  public:
    typedef StringSequence_var _var_type;
    inline StringSequence() {}
    inline StringSequence(const StringSequence& _s)
      : _CORBA_Unbounded_Sequence_String(_s) {}

    inline StringSequence(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_String(_max) {}
    inline StringSequence(_CORBA_ULong _max, _CORBA_ULong _len, char** _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_String(_max, _len, _val, _rel) {}

  

    inline StringSequence& operator = (const StringSequence& _s) {
      _CORBA_Unbounded_Sequence_String::operator=(_s);
      return *this;
    }
  };

  class StringSequence_out;

  class StringSequence_var {
  public:
    inline StringSequence_var() : _pd_seq(0) {}
    inline StringSequence_var(StringSequence* _s) : _pd_seq(_s) {}
    inline StringSequence_var(const StringSequence_var& _s) {
      if (_s._pd_seq)  _pd_seq = new StringSequence(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~StringSequence_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline StringSequence_var& operator = (StringSequence* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline StringSequence_var& operator = (const StringSequence_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new StringSequence;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline _CORBA_String_element operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline StringSequence* operator -> () { return _pd_seq; }
    inline const StringSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator StringSequence& () const { return *_pd_seq; }
#else
    inline operator const StringSequence& () const { return *_pd_seq; }
    inline operator StringSequence& () { return *_pd_seq; }
#endif
      
    inline const StringSequence& in() const { return *_pd_seq; }
    inline StringSequence&       inout()    { return *_pd_seq; }
    inline StringSequence*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline StringSequence* _retn() { StringSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class StringSequence_out;
    
  private:
    StringSequence* _pd_seq;
  };

  class StringSequence_out {
  public:
    inline StringSequence_out(StringSequence*& _s) : _data(_s) { _data = 0; }
    inline StringSequence_out(StringSequence_var& _s)
      : _data(_s._pd_seq) { _s = (StringSequence*) 0; }
    inline StringSequence_out(const StringSequence_out& _s) : _data(_s._data) {}
    inline StringSequence_out& operator = (const StringSequence_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline StringSequence_out& operator = (StringSequence* _s) {
      _data = _s;
      return *this;
    }
    inline operator StringSequence*&()  { return _data; }
    inline StringSequence*& ptr()       { return _data; }
    inline StringSequence* operator->() { return _data; }

    inline _CORBA_String_element operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    StringSequence*& _data;

  private:
    StringSequence_out();
    StringSequence_out& operator=(const StringSequence_var&);
  };

  class UnknownProperties : public ::CORBA::UserException {
  public:
    
    Properties invalidProperties;

  

    inline UnknownProperties() {
      pd_insertToAnyFn    = insertToAnyFn;
      pd_insertToAnyFnNCP = insertToAnyFnNCP;
    }
    UnknownProperties(const UnknownProperties&);
    UnknownProperties(const Properties i_invalidProperties);
    UnknownProperties& operator=(const UnknownProperties&);
    virtual ~UnknownProperties();
    virtual void _raise() const;
    static UnknownProperties* _downcast(::CORBA::Exception*);
    static const UnknownProperties* _downcast(const ::CORBA::Exception*);
    static inline UnknownProperties* _narrow(::CORBA::Exception* _e) {
      return _downcast(_e);
    }
    
    void operator>>=(cdrStream&) const ;
    void operator<<=(cdrStream&) ;

    static _core_attr insertExceptionToAny    insertToAnyFn;
    static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

    virtual ::CORBA::Exception* _NP_duplicate() const;

    static _core_attr const char* _PD_repoId;
    static _core_attr const char* _PD_typeId;

  private:
    virtual const char* _NP_typeId() const;
    virtual const char* _NP_repoId(int*) const;
    virtual void _NP_marshal(cdrStream&) const;
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_UnknownProperties;

  struct DeviceAssignmentType {
    typedef _CORBA_ConstrType_Variable_Var<DeviceAssignmentType> _var_type;

    
    ::CORBA::String_member componentId;

    ::CORBA::String_member assignedDeviceId;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef DeviceAssignmentType::_var_type DeviceAssignmentType_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< DeviceAssignmentType,DeviceAssignmentType_var > DeviceAssignmentType_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_DeviceAssignmentType;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_DeviceAssignmentSequence;

  class DeviceAssignmentSequence_var;

  class DeviceAssignmentSequence : public _CORBA_Unbounded_Sequence< DeviceAssignmentType >  {
  public:
    typedef DeviceAssignmentSequence_var _var_type;
    inline DeviceAssignmentSequence() {}
    inline DeviceAssignmentSequence(const DeviceAssignmentSequence& _s)
      : _CORBA_Unbounded_Sequence< DeviceAssignmentType > (_s) {}

    inline DeviceAssignmentSequence(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< DeviceAssignmentType > (_max) {}
    inline DeviceAssignmentSequence(_CORBA_ULong _max, _CORBA_ULong _len, DeviceAssignmentType* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< DeviceAssignmentType > (_max, _len, _val, _rel) {}

  

    inline DeviceAssignmentSequence& operator = (const DeviceAssignmentSequence& _s) {
      _CORBA_Unbounded_Sequence< DeviceAssignmentType > ::operator=(_s);
      return *this;
    }
  };

  class DeviceAssignmentSequence_out;

  class DeviceAssignmentSequence_var {
  public:
    inline DeviceAssignmentSequence_var() : _pd_seq(0) {}
    inline DeviceAssignmentSequence_var(DeviceAssignmentSequence* _s) : _pd_seq(_s) {}
    inline DeviceAssignmentSequence_var(const DeviceAssignmentSequence_var& _s) {
      if (_s._pd_seq)  _pd_seq = new DeviceAssignmentSequence(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~DeviceAssignmentSequence_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline DeviceAssignmentSequence_var& operator = (DeviceAssignmentSequence* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline DeviceAssignmentSequence_var& operator = (const DeviceAssignmentSequence_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new DeviceAssignmentSequence;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline DeviceAssignmentType& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline DeviceAssignmentSequence* operator -> () { return _pd_seq; }
    inline const DeviceAssignmentSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator DeviceAssignmentSequence& () const { return *_pd_seq; }
#else
    inline operator const DeviceAssignmentSequence& () const { return *_pd_seq; }
    inline operator DeviceAssignmentSequence& () { return *_pd_seq; }
#endif
      
    inline const DeviceAssignmentSequence& in() const { return *_pd_seq; }
    inline DeviceAssignmentSequence&       inout()    { return *_pd_seq; }
    inline DeviceAssignmentSequence*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline DeviceAssignmentSequence* _retn() { DeviceAssignmentSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class DeviceAssignmentSequence_out;
    
  private:
    DeviceAssignmentSequence* _pd_seq;
  };

  class DeviceAssignmentSequence_out {
  public:
    inline DeviceAssignmentSequence_out(DeviceAssignmentSequence*& _s) : _data(_s) { _data = 0; }
    inline DeviceAssignmentSequence_out(DeviceAssignmentSequence_var& _s)
      : _data(_s._pd_seq) { _s = (DeviceAssignmentSequence*) 0; }
    inline DeviceAssignmentSequence_out(const DeviceAssignmentSequence_out& _s) : _data(_s._data) {}
    inline DeviceAssignmentSequence_out& operator = (const DeviceAssignmentSequence_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline DeviceAssignmentSequence_out& operator = (DeviceAssignmentSequence* _s) {
      _data = _s;
      return *this;
    }
    inline operator DeviceAssignmentSequence*&()  { return _data; }
    inline DeviceAssignmentSequence*& ptr()       { return _data; }
    inline DeviceAssignmentSequence* operator->() { return _data; }

    inline DeviceAssignmentType& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    DeviceAssignmentSequence*& _data;

  private:
    DeviceAssignmentSequence_out();
    DeviceAssignmentSequence_out& operator=(const DeviceAssignmentSequence_var&);
  };

  enum ErrorNumberType { CFNOTSET, CFE2BIG, CFEACCES, CFEAGAIN, CFEBADF, CFEBADMSG, CFEBUSY, CFECANCELED, CFECHILD, CFEDEADLK, CFEDOM, CFEEXIST, CFEFAULT, CFEFBIG, CFEINPROGRESS, CFEINTR, CFEINVAL, CFEIO, CFEISDIR, CFEMFILE, CFEMLINK, CFEMSGSIZE, CFENAMETOOLONG, CFENFILE, CFENODEV, CFENOENT, CFENOEXEC, CFENOLCK, CFENOMEM, CFENOSPC, CFENOSYS, CFENOTDIR, CFENOTEMPTY, CFENOTSUP, CFENOTTY, CFENXIO, CFEPERM, CFEPIPE, CFERANGE, CFEROFS, CFESPIPE, CFESRCH, CFETIMEDOUT, CFEXDEV /*, __max_ErrorNumberType=0xffffffff */ };
  typedef ErrorNumberType& ErrorNumberType_out;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ErrorNumberType;

  class InvalidFileName : public ::CORBA::UserException {
  public:
    
    ErrorNumberType errorNumber;

    ::CORBA::String_member msg;

  

    inline InvalidFileName() {
      pd_insertToAnyFn    = insertToAnyFn;
      pd_insertToAnyFnNCP = insertToAnyFnNCP;
    }
    InvalidFileName(const InvalidFileName&);
    InvalidFileName(ErrorNumberType i_errorNumber, const char* i_msg);
    InvalidFileName& operator=(const InvalidFileName&);
    virtual ~InvalidFileName();
    virtual void _raise() const;
    static InvalidFileName* _downcast(::CORBA::Exception*);
    static const InvalidFileName* _downcast(const ::CORBA::Exception*);
    static inline InvalidFileName* _narrow(::CORBA::Exception* _e) {
      return _downcast(_e);
    }
    
    void operator>>=(cdrStream&) const ;
    void operator<<=(cdrStream&) ;

    static _core_attr insertExceptionToAny    insertToAnyFn;
    static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

    virtual ::CORBA::Exception* _NP_duplicate() const;

    static _core_attr const char* _PD_repoId;
    static _core_attr const char* _PD_typeId;

  private:
    virtual const char* _NP_typeId() const;
    virtual const char* _NP_repoId(int*) const;
    virtual void _NP_marshal(cdrStream&) const;
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_InvalidFileName;

  class FileException : public ::CORBA::UserException {
  public:
    
    ErrorNumberType errorNumber;

    ::CORBA::String_member msg;

  

    inline FileException() {
      pd_insertToAnyFn    = insertToAnyFn;
      pd_insertToAnyFnNCP = insertToAnyFnNCP;
    }
    FileException(const FileException&);
    FileException(ErrorNumberType i_errorNumber, const char* i_msg);
    FileException& operator=(const FileException&);
    virtual ~FileException();
    virtual void _raise() const;
    static FileException* _downcast(::CORBA::Exception*);
    static const FileException* _downcast(const ::CORBA::Exception*);
    static inline FileException* _narrow(::CORBA::Exception* _e) {
      return _downcast(_e);
    }
    
    void operator>>=(cdrStream&) const ;
    void operator<<=(cdrStream&) ;

    static _core_attr insertExceptionToAny    insertToAnyFn;
    static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

    virtual ::CORBA::Exception* _NP_duplicate() const;

    static _core_attr const char* _PD_repoId;
    static _core_attr const char* _PD_typeId;

  private:
    virtual const char* _NP_typeId() const;
    virtual const char* _NP_repoId(int*) const;
    virtual void _NP_marshal(cdrStream&) const;
  };

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_FileException;

  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_DeviceSequence;

  class DeviceSequence_var;

  class DeviceSequence : public _CORBA_Unbounded_Sequence_ObjRef< _objref_Device, _CORBA_ObjRef_Element< _objref_Device, Device_Helper> , Device_Helper >  {
  public:
    typedef DeviceSequence_var _var_type;
    inline DeviceSequence() {}
    inline DeviceSequence(const DeviceSequence& _s)
      : _CORBA_Unbounded_Sequence_ObjRef< _objref_Device, _CORBA_ObjRef_Element< _objref_Device, Device_Helper> , Device_Helper > (_s) {}

    inline DeviceSequence(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_ObjRef< _objref_Device, _CORBA_ObjRef_Element< _objref_Device, Device_Helper> , Device_Helper > (_max) {}
    inline DeviceSequence(_CORBA_ULong _max, _CORBA_ULong _len, Device_ptr* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_ObjRef< _objref_Device, _CORBA_ObjRef_Element< _objref_Device, Device_Helper> , Device_Helper > (_max, _len, _val, _rel) {}

  

    inline DeviceSequence& operator = (const DeviceSequence& _s) {
      _CORBA_Unbounded_Sequence_ObjRef< _objref_Device, _CORBA_ObjRef_Element< _objref_Device, Device_Helper> , Device_Helper > ::operator=(_s);
      return *this;
    }
  };

  class DeviceSequence_out;

  class DeviceSequence_var {
  public:
    inline DeviceSequence_var() : _pd_seq(0) {}
    inline DeviceSequence_var(DeviceSequence* _s) : _pd_seq(_s) {}
    inline DeviceSequence_var(const DeviceSequence_var& _s) {
      if (_s._pd_seq)  _pd_seq = new DeviceSequence(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~DeviceSequence_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline DeviceSequence_var& operator = (DeviceSequence* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline DeviceSequence_var& operator = (const DeviceSequence_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new DeviceSequence;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline _CORBA_ObjRef_Element< _objref_Device, Device_Helper>  operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline DeviceSequence* operator -> () { return _pd_seq; }
    inline const DeviceSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator DeviceSequence& () const { return *_pd_seq; }
#else
    inline operator const DeviceSequence& () const { return *_pd_seq; }
    inline operator DeviceSequence& () { return *_pd_seq; }
#endif
      
    inline const DeviceSequence& in() const { return *_pd_seq; }
    inline DeviceSequence&       inout()    { return *_pd_seq; }
    inline DeviceSequence*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline DeviceSequence* _retn() { DeviceSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class DeviceSequence_out;
    
  private:
    DeviceSequence* _pd_seq;
  };

  class DeviceSequence_out {
  public:
    inline DeviceSequence_out(DeviceSequence*& _s) : _data(_s) { _data = 0; }
    inline DeviceSequence_out(DeviceSequence_var& _s)
      : _data(_s._pd_seq) { _s = (DeviceSequence*) 0; }
    inline DeviceSequence_out(const DeviceSequence_out& _s) : _data(_s._data) {}
    inline DeviceSequence_out& operator = (const DeviceSequence_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline DeviceSequence_out& operator = (DeviceSequence* _s) {
      _data = _s;
      return *this;
    }
    inline operator DeviceSequence*&()  { return _data; }
    inline DeviceSequence*& ptr()       { return _data; }
    inline DeviceSequence* operator->() { return _data; }

    inline _CORBA_ObjRef_Element< _objref_Device, Device_Helper>  operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    DeviceSequence*& _data;

  private:
    DeviceSequence_out();
    DeviceSequence_out& operator=(const DeviceSequence_var&);
  };

#ifndef __CF_mAggregateDevice__
#define __CF_mAggregateDevice__
  class AggregateDevice;
  class _objref_AggregateDevice;
  class _impl_AggregateDevice;
  
  typedef _objref_AggregateDevice* AggregateDevice_ptr;
  typedef AggregateDevice_ptr AggregateDeviceRef;

  class AggregateDevice_Helper {
  public:
    typedef AggregateDevice_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_AggregateDevice, AggregateDevice_Helper> AggregateDevice_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_AggregateDevice,AggregateDevice_Helper > AggregateDevice_out;

#endif

  // interface AggregateDevice
  class AggregateDevice {
  public:
    // Declarations for this interface type.
    typedef AggregateDevice_ptr _ptr_type;
    typedef AggregateDevice_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_AggregateDevice :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    // IDL operations
    DeviceSequence* devices();
    void addDevice(::CF::Device_ptr associatedDevice);
    void removeDevice(::CF::Device_ptr associatedDevice);

    // Constructors
    inline _objref_AggregateDevice()  { _PR_setobj(0); }  // nil
    _objref_AggregateDevice(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_AggregateDevice();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_AggregateDevice(const _objref_AggregateDevice&);
    _objref_AggregateDevice& operator = (const _objref_AggregateDevice&);
    // not implemented

    friend class AggregateDevice;
  };

  class _pof_AggregateDevice : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_AggregateDevice() : _OMNI_NS(proxyObjectFactory)(AggregateDevice::_PD_repoId) {}
    virtual ~_pof_AggregateDevice();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_AggregateDevice :
    public virtual omniServant
  {
  public:
    virtual ~_impl_AggregateDevice();

    virtual DeviceSequence* devices() = 0;
    virtual void addDevice(::CF::Device_ptr associatedDevice) = 0;
    virtual void removeDevice(::CF::Device_ptr associatedDevice) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_AggregateDevice;

#ifndef __CF_mFileSystem__
#define __CF_mFileSystem__
  class FileSystem;
  class _objref_FileSystem;
  class _impl_FileSystem;
  
  typedef _objref_FileSystem* FileSystem_ptr;
  typedef FileSystem_ptr FileSystemRef;

  class FileSystem_Helper {
  public:
    typedef FileSystem_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_FileSystem, FileSystem_Helper> FileSystem_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_FileSystem,FileSystem_Helper > FileSystem_out;

#endif

  // interface FileSystem
  class FileSystem {
  public:
    // Declarations for this interface type.
    typedef FileSystem_ptr _ptr_type;
    typedef FileSystem_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    class UnknownFileSystemProperties : public ::CORBA::UserException {
    public:
      
      Properties invalidProperties;

    

      inline UnknownFileSystemProperties() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      UnknownFileSystemProperties(const UnknownFileSystemProperties&);
      UnknownFileSystemProperties(const Properties i_invalidProperties);
      UnknownFileSystemProperties& operator=(const UnknownFileSystemProperties&);
      virtual ~UnknownFileSystemProperties();
      virtual void _raise() const;
      static UnknownFileSystemProperties* _downcast(::CORBA::Exception*);
      static const UnknownFileSystemProperties* _downcast(const ::CORBA::Exception*);
      static inline UnknownFileSystemProperties* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      void operator>>=(cdrStream&) const ;
      void operator<<=(cdrStream&) ;

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_UnknownFileSystemProperties;

    static _core_attr const char * SIZE;

    static _core_attr const char * AVAILABLE_SIZE;

    enum FileType { PLAIN, DIRECTORY, FILE_SYSTEM /*, __max_FileType=0xffffffff */ };
    typedef FileType& FileType_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_FileType;

    struct FileInformationType {
      typedef _CORBA_ConstrType_Variable_Var<FileInformationType> _var_type;

      
      ::CORBA::String_member name;

      FileType kind;

      ::CORBA::ULongLong size;

      Properties fileProperties;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef FileInformationType::_var_type FileInformationType_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< FileInformationType,FileInformationType_var > FileInformationType_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_FileInformationType;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_FileInformationSequence;

    class FileInformationSequence_var;

    class FileInformationSequence : public _CORBA_Unbounded_Sequence< FileInformationType >  {
    public:
      typedef FileInformationSequence_var _var_type;
      inline FileInformationSequence() {}
      inline FileInformationSequence(const FileInformationSequence& _s)
        : _CORBA_Unbounded_Sequence< FileInformationType > (_s) {}

      inline FileInformationSequence(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence< FileInformationType > (_max) {}
      inline FileInformationSequence(_CORBA_ULong _max, _CORBA_ULong _len, FileInformationType* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence< FileInformationType > (_max, _len, _val, _rel) {}

    

      inline FileInformationSequence& operator = (const FileInformationSequence& _s) {
        _CORBA_Unbounded_Sequence< FileInformationType > ::operator=(_s);
        return *this;
      }
    };

    class FileInformationSequence_out;

    class FileInformationSequence_var {
    public:
      inline FileInformationSequence_var() : _pd_seq(0) {}
      inline FileInformationSequence_var(FileInformationSequence* _s) : _pd_seq(_s) {}
      inline FileInformationSequence_var(const FileInformationSequence_var& _s) {
        if (_s._pd_seq)  _pd_seq = new FileInformationSequence(*_s._pd_seq);
        else             _pd_seq = 0;
      }
      inline ~FileInformationSequence_var() { if (_pd_seq)  delete _pd_seq; }
        
      inline FileInformationSequence_var& operator = (FileInformationSequence* _s) {
        if (_pd_seq)  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline FileInformationSequence_var& operator = (const FileInformationSequence_var& _s) {
        if (&_s != this) {
          if (_s._pd_seq) {
            if (!_pd_seq)  _pd_seq = new FileInformationSequence;
            *_pd_seq = *_s._pd_seq;
          }
          else if (_pd_seq) {
            delete _pd_seq;
            _pd_seq = 0;
          }
        }
        return *this;
      }
      inline FileInformationType& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline FileInformationSequence* operator -> () { return _pd_seq; }
      inline const FileInformationSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator FileInformationSequence& () const { return *_pd_seq; }
#else
      inline operator const FileInformationSequence& () const { return *_pd_seq; }
      inline operator FileInformationSequence& () { return *_pd_seq; }
#endif
        
      inline const FileInformationSequence& in() const { return *_pd_seq; }
      inline FileInformationSequence&       inout()    { return *_pd_seq; }
      inline FileInformationSequence*&      out() {
        if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline FileInformationSequence* _retn() { FileInformationSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class FileInformationSequence_out;
      
    private:
      FileInformationSequence* _pd_seq;
    };

    class FileInformationSequence_out {
    public:
      inline FileInformationSequence_out(FileInformationSequence*& _s) : _data(_s) { _data = 0; }
      inline FileInformationSequence_out(FileInformationSequence_var& _s)
        : _data(_s._pd_seq) { _s = (FileInformationSequence*) 0; }
      inline FileInformationSequence_out(const FileInformationSequence_out& _s) : _data(_s._data) {}
      inline FileInformationSequence_out& operator = (const FileInformationSequence_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline FileInformationSequence_out& operator = (FileInformationSequence* _s) {
        _data = _s;
        return *this;
      }
      inline operator FileInformationSequence*&()  { return _data; }
      inline FileInformationSequence*& ptr()       { return _data; }
      inline FileInformationSequence* operator->() { return _data; }

      inline FileInformationType& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      FileInformationSequence*& _data;

    private:
      FileInformationSequence_out();
      FileInformationSequence_out& operator=(const FileInformationSequence_var&);
    };

    static _core_attr const char * CREATED_TIME_ID;

    static _core_attr const char * MODIFIED_TIME_ID;

    static _core_attr const char * LAST_ACCESS_TIME_ID;

  
  };

  class _objref_FileSystem :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    // IDL operations
    void remove(const char* fileName);
    void copy(const char* sourceFileName, const char* destinationFileName);
    ::CORBA::Boolean exists(const char* fileName);
    FileSystem::FileInformationSequence* list(const char* pattern);
    File_ptr create(const char* fileName);
    File_ptr open(const char* fileName, ::CORBA::Boolean read_Only);
    void mkdir(const char* directoryName);
    void rmdir(const char* directoryName);
    void query(::CF::Properties& fileSystemProperties);

    // Constructors
    inline _objref_FileSystem()  { _PR_setobj(0); }  // nil
    _objref_FileSystem(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_FileSystem();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_FileSystem(const _objref_FileSystem&);
    _objref_FileSystem& operator = (const _objref_FileSystem&);
    // not implemented

    friend class FileSystem;
  };

  class _pof_FileSystem : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_FileSystem() : _OMNI_NS(proxyObjectFactory)(FileSystem::_PD_repoId) {}
    virtual ~_pof_FileSystem();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_FileSystem :
    public virtual omniServant
  {
  public:
    virtual ~_impl_FileSystem();

    virtual void remove(const char* fileName) = 0;
    virtual void copy(const char* sourceFileName, const char* destinationFileName) = 0;
    virtual ::CORBA::Boolean exists(const char* fileName) = 0;
    virtual FileSystem::FileInformationSequence* list(const char* pattern) = 0;
    virtual File_ptr create(const char* fileName) = 0;
    virtual File_ptr open(const char* fileName, ::CORBA::Boolean read_Only) = 0;
    virtual void mkdir(const char* directoryName) = 0;
    virtual void rmdir(const char* directoryName) = 0;
    virtual void query(::CF::Properties& fileSystemProperties) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_FileSystem;

#ifndef __CF_mFile__
#define __CF_mFile__
  class File;
  class _objref_File;
  class _impl_File;
  
  typedef _objref_File* File_ptr;
  typedef File_ptr FileRef;

  class File_Helper {
  public:
    typedef File_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_File, File_Helper> File_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_File,File_Helper > File_out;

#endif

  // interface File
  class File {
  public:
    // Declarations for this interface type.
    typedef File_ptr _ptr_type;
    typedef File_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    class IOException : public ::CORBA::UserException {
    public:
      
      ErrorNumberType errorNumber;

      ::CORBA::String_member msg;

    

      inline IOException() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      IOException(const IOException&);
      IOException(ErrorNumberType i_errorNumber, const char* i_msg);
      IOException& operator=(const IOException&);
      virtual ~IOException();
      virtual void _raise() const;
      static IOException* _downcast(::CORBA::Exception*);
      static const IOException* _downcast(const ::CORBA::Exception*);
      static inline IOException* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      void operator>>=(cdrStream&) const ;
      void operator<<=(cdrStream&) ;

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_IOException;

    class InvalidFilePointer : public ::CORBA::UserException {
    public:
      
      

      inline InvalidFilePointer() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      InvalidFilePointer(const InvalidFilePointer&);
      
      InvalidFilePointer& operator=(const InvalidFilePointer&);
      virtual ~InvalidFilePointer();
      virtual void _raise() const;
      static InvalidFilePointer* _downcast(::CORBA::Exception*);
      static const InvalidFilePointer* _downcast(const ::CORBA::Exception*);
      static inline InvalidFilePointer* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      inline void operator>>=(cdrStream&) const { }
      inline void operator<<=(cdrStream&) { }

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_InvalidFilePointer;

  
  };

  class _objref_File :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    // IDL operations
    char* fileName();
    ::CORBA::ULong filePointer();
    void read(::CF::OctetSequence_out data, ::CORBA::ULong length);
    void write(const ::CF::OctetSequence& data);
    ::CORBA::ULong sizeOf();
    void close();
    void setFilePointer(::CORBA::ULong filePointer);

    // Constructors
    inline _objref_File()  { _PR_setobj(0); }  // nil
    _objref_File(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_File();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_File(const _objref_File&);
    _objref_File& operator = (const _objref_File&);
    // not implemented

    friend class File;
  };

  class _pof_File : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_File() : _OMNI_NS(proxyObjectFactory)(File::_PD_repoId) {}
    virtual ~_pof_File();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_File :
    public virtual omniServant
  {
  public:
    virtual ~_impl_File();

    virtual char* fileName() = 0;
    virtual ::CORBA::ULong filePointer() = 0;
    virtual void read(::CF::OctetSequence_out data, ::CORBA::ULong length) = 0;
    virtual void write(const ::CF::OctetSequence& data) = 0;
    virtual ::CORBA::ULong sizeOf() = 0;
    virtual void close() = 0;
    virtual void setFilePointer(::CORBA::ULong filePointer) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_File;

#ifndef __CF_mResourceFactory__
#define __CF_mResourceFactory__
  class ResourceFactory;
  class _objref_ResourceFactory;
  class _impl_ResourceFactory;
  
  typedef _objref_ResourceFactory* ResourceFactory_ptr;
  typedef ResourceFactory_ptr ResourceFactoryRef;

  class ResourceFactory_Helper {
  public:
    typedef ResourceFactory_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_ResourceFactory, ResourceFactory_Helper> ResourceFactory_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_ResourceFactory,ResourceFactory_Helper > ResourceFactory_out;

#endif

  // interface ResourceFactory
  class ResourceFactory {
  public:
    // Declarations for this interface type.
    typedef ResourceFactory_ptr _ptr_type;
    typedef ResourceFactory_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    class InvalidResourceId : public ::CORBA::UserException {
    public:
      
      

      inline InvalidResourceId() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      InvalidResourceId(const InvalidResourceId&);
      
      InvalidResourceId& operator=(const InvalidResourceId&);
      virtual ~InvalidResourceId();
      virtual void _raise() const;
      static InvalidResourceId* _downcast(::CORBA::Exception*);
      static const InvalidResourceId* _downcast(const ::CORBA::Exception*);
      static inline InvalidResourceId* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      inline void operator>>=(cdrStream&) const { }
      inline void operator<<=(cdrStream&) { }

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_InvalidResourceId;

    class ShutdownFailure : public ::CORBA::UserException {
    public:
      
      ::CORBA::String_member msg;

    

      inline ShutdownFailure() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      ShutdownFailure(const ShutdownFailure&);
      ShutdownFailure(const char* i_msg);
      ShutdownFailure& operator=(const ShutdownFailure&);
      virtual ~ShutdownFailure();
      virtual void _raise() const;
      static ShutdownFailure* _downcast(::CORBA::Exception*);
      static const ShutdownFailure* _downcast(const ::CORBA::Exception*);
      static inline ShutdownFailure* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      void operator>>=(cdrStream&) const ;
      void operator<<=(cdrStream&) ;

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_ShutdownFailure;

    class CreateResourceFailure : public ::CORBA::UserException {
    public:
      
      ErrorNumberType errorNumber;

      ::CORBA::String_member msg;

    

      inline CreateResourceFailure() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      CreateResourceFailure(const CreateResourceFailure&);
      CreateResourceFailure(ErrorNumberType i_errorNumber, const char* i_msg);
      CreateResourceFailure& operator=(const CreateResourceFailure&);
      virtual ~CreateResourceFailure();
      virtual void _raise() const;
      static CreateResourceFailure* _downcast(::CORBA::Exception*);
      static const CreateResourceFailure* _downcast(const ::CORBA::Exception*);
      static inline CreateResourceFailure* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      void operator>>=(cdrStream&) const ;
      void operator<<=(cdrStream&) ;

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_CreateResourceFailure;

  
  };

  class _objref_ResourceFactory :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    // IDL operations
    char* identifier();
    Resource_ptr createResource(const char* resourceId, const ::CF::Properties& qualifiers);
    void releaseResource(const char* resourceId);
    void shutdown();

    // Constructors
    inline _objref_ResourceFactory()  { _PR_setobj(0); }  // nil
    _objref_ResourceFactory(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_ResourceFactory();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_ResourceFactory(const _objref_ResourceFactory&);
    _objref_ResourceFactory& operator = (const _objref_ResourceFactory&);
    // not implemented

    friend class ResourceFactory;
  };

  class _pof_ResourceFactory : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_ResourceFactory() : _OMNI_NS(proxyObjectFactory)(ResourceFactory::_PD_repoId) {}
    virtual ~_pof_ResourceFactory();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_ResourceFactory :
    public virtual omniServant
  {
  public:
    virtual ~_impl_ResourceFactory();

    virtual char* identifier() = 0;
    virtual Resource_ptr createResource(const char* resourceId, const ::CF::Properties& qualifiers) = 0;
    virtual void releaseResource(const char* resourceId) = 0;
    virtual void shutdown() = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ResourceFactory;

#ifndef __CF_mFileManager__
#define __CF_mFileManager__
  class FileManager;
  class _objref_FileManager;
  class _impl_FileManager;
  
  typedef _objref_FileManager* FileManager_ptr;
  typedef FileManager_ptr FileManagerRef;

  class FileManager_Helper {
  public:
    typedef FileManager_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_FileManager, FileManager_Helper> FileManager_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_FileManager,FileManager_Helper > FileManager_out;

#endif

  // interface FileManager
  class FileManager {
  public:
    // Declarations for this interface type.
    typedef FileManager_ptr _ptr_type;
    typedef FileManager_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    struct MountType {
      typedef _CORBA_ConstrType_Variable_Var<MountType> _var_type;

      
      ::CORBA::String_member mountPoint;

      _CORBA_ObjRef_Member< _objref_FileSystem, FileSystem_Helper>  fs;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef MountType::_var_type MountType_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< MountType,MountType_var > MountType_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_MountType;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_MountSequence;

    class MountSequence_var;

    class MountSequence : public _CORBA_Unbounded_Sequence< MountType >  {
    public:
      typedef MountSequence_var _var_type;
      inline MountSequence() {}
      inline MountSequence(const MountSequence& _s)
        : _CORBA_Unbounded_Sequence< MountType > (_s) {}

      inline MountSequence(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence< MountType > (_max) {}
      inline MountSequence(_CORBA_ULong _max, _CORBA_ULong _len, MountType* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence< MountType > (_max, _len, _val, _rel) {}

    

      inline MountSequence& operator = (const MountSequence& _s) {
        _CORBA_Unbounded_Sequence< MountType > ::operator=(_s);
        return *this;
      }
    };

    class MountSequence_out;

    class MountSequence_var {
    public:
      inline MountSequence_var() : _pd_seq(0) {}
      inline MountSequence_var(MountSequence* _s) : _pd_seq(_s) {}
      inline MountSequence_var(const MountSequence_var& _s) {
        if (_s._pd_seq)  _pd_seq = new MountSequence(*_s._pd_seq);
        else             _pd_seq = 0;
      }
      inline ~MountSequence_var() { if (_pd_seq)  delete _pd_seq; }
        
      inline MountSequence_var& operator = (MountSequence* _s) {
        if (_pd_seq)  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline MountSequence_var& operator = (const MountSequence_var& _s) {
        if (&_s != this) {
          if (_s._pd_seq) {
            if (!_pd_seq)  _pd_seq = new MountSequence;
            *_pd_seq = *_s._pd_seq;
          }
          else if (_pd_seq) {
            delete _pd_seq;
            _pd_seq = 0;
          }
        }
        return *this;
      }
      inline MountType& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline MountSequence* operator -> () { return _pd_seq; }
      inline const MountSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator MountSequence& () const { return *_pd_seq; }
#else
      inline operator const MountSequence& () const { return *_pd_seq; }
      inline operator MountSequence& () { return *_pd_seq; }
#endif
        
      inline const MountSequence& in() const { return *_pd_seq; }
      inline MountSequence&       inout()    { return *_pd_seq; }
      inline MountSequence*&      out() {
        if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline MountSequence* _retn() { MountSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class MountSequence_out;
      
    private:
      MountSequence* _pd_seq;
    };

    class MountSequence_out {
    public:
      inline MountSequence_out(MountSequence*& _s) : _data(_s) { _data = 0; }
      inline MountSequence_out(MountSequence_var& _s)
        : _data(_s._pd_seq) { _s = (MountSequence*) 0; }
      inline MountSequence_out(const MountSequence_out& _s) : _data(_s._data) {}
      inline MountSequence_out& operator = (const MountSequence_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline MountSequence_out& operator = (MountSequence* _s) {
        _data = _s;
        return *this;
      }
      inline operator MountSequence*&()  { return _data; }
      inline MountSequence*& ptr()       { return _data; }
      inline MountSequence* operator->() { return _data; }

      inline MountType& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      MountSequence*& _data;

    private:
      MountSequence_out();
      MountSequence_out& operator=(const MountSequence_var&);
    };

    class NonExistentMount : public ::CORBA::UserException {
    public:
      
      

      inline NonExistentMount() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      NonExistentMount(const NonExistentMount&);
      
      NonExistentMount& operator=(const NonExistentMount&);
      virtual ~NonExistentMount();
      virtual void _raise() const;
      static NonExistentMount* _downcast(::CORBA::Exception*);
      static const NonExistentMount* _downcast(const ::CORBA::Exception*);
      static inline NonExistentMount* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      inline void operator>>=(cdrStream&) const { }
      inline void operator<<=(cdrStream&) { }

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_NonExistentMount;

    class InvalidFileSystem : public ::CORBA::UserException {
    public:
      
      

      inline InvalidFileSystem() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      InvalidFileSystem(const InvalidFileSystem&);
      
      InvalidFileSystem& operator=(const InvalidFileSystem&);
      virtual ~InvalidFileSystem();
      virtual void _raise() const;
      static InvalidFileSystem* _downcast(::CORBA::Exception*);
      static const InvalidFileSystem* _downcast(const ::CORBA::Exception*);
      static inline InvalidFileSystem* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      inline void operator>>=(cdrStream&) const { }
      inline void operator<<=(cdrStream&) { }

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_InvalidFileSystem;

    class MountPointAlreadyExists : public ::CORBA::UserException {
    public:
      
      

      inline MountPointAlreadyExists() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      MountPointAlreadyExists(const MountPointAlreadyExists&);
      
      MountPointAlreadyExists& operator=(const MountPointAlreadyExists&);
      virtual ~MountPointAlreadyExists();
      virtual void _raise() const;
      static MountPointAlreadyExists* _downcast(::CORBA::Exception*);
      static const MountPointAlreadyExists* _downcast(const ::CORBA::Exception*);
      static inline MountPointAlreadyExists* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      inline void operator>>=(cdrStream&) const { }
      inline void operator<<=(cdrStream&) { }

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_MountPointAlreadyExists;

  
  };

  class _objref_FileManager :
    public virtual _objref_FileSystem
  {
  public:
    // IDL operations
    void mount(const char* mountPoint, ::CF::FileSystem_ptr file_System);
    void unmount(const char* mountPoint);
    FileManager::MountSequence* getMounts();

    // Constructors
    inline _objref_FileManager()  { _PR_setobj(0); }  // nil
    _objref_FileManager(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_FileManager();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_FileManager(const _objref_FileManager&);
    _objref_FileManager& operator = (const _objref_FileManager&);
    // not implemented

    friend class FileManager;
  };

  class _pof_FileManager : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_FileManager() : _OMNI_NS(proxyObjectFactory)(FileManager::_PD_repoId) {}
    virtual ~_pof_FileManager();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_FileManager :
    public virtual _impl_FileSystem
  {
  public:
    virtual ~_impl_FileManager();

    virtual void mount(const char* mountPoint, ::CF::FileSystem_ptr file_System) = 0;
    virtual void unmount(const char* mountPoint) = 0;
    virtual FileManager::MountSequence* getMounts() = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_FileManager;

#ifndef __CF_mPort__
#define __CF_mPort__
  class Port;
  class _objref_Port;
  class _impl_Port;
  
  typedef _objref_Port* Port_ptr;
  typedef Port_ptr PortRef;

  class Port_Helper {
  public:
    typedef Port_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_Port, Port_Helper> Port_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_Port,Port_Helper > Port_out;

#endif

  // interface Port
  class Port {
  public:
    // Declarations for this interface type.
    typedef Port_ptr _ptr_type;
    typedef Port_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    class InvalidPort : public ::CORBA::UserException {
    public:
      
      ::CORBA::UShort errorCode;

      ::CORBA::String_member msg;

    

      inline InvalidPort() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      InvalidPort(const InvalidPort&);
      InvalidPort(::CORBA::UShort i_errorCode, const char* i_msg);
      InvalidPort& operator=(const InvalidPort&);
      virtual ~InvalidPort();
      virtual void _raise() const;
      static InvalidPort* _downcast(::CORBA::Exception*);
      static const InvalidPort* _downcast(const ::CORBA::Exception*);
      static inline InvalidPort* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      void operator>>=(cdrStream&) const ;
      void operator<<=(cdrStream&) ;

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_InvalidPort;

    class OccupiedPort : public ::CORBA::UserException {
    public:
      
      

      inline OccupiedPort() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      OccupiedPort(const OccupiedPort&);
      
      OccupiedPort& operator=(const OccupiedPort&);
      virtual ~OccupiedPort();
      virtual void _raise() const;
      static OccupiedPort* _downcast(::CORBA::Exception*);
      static const OccupiedPort* _downcast(const ::CORBA::Exception*);
      static inline OccupiedPort* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      inline void operator>>=(cdrStream&) const { }
      inline void operator<<=(cdrStream&) { }

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_OccupiedPort;

  
  };

  class _objref_Port :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    // IDL operations
    void connectPort(::CORBA::Object_ptr connection, const char* connectionId);
    void disconnectPort(const char* connectionId);

    // Constructors
    inline _objref_Port()  { _PR_setobj(0); }  // nil
    _objref_Port(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_Port();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_Port(const _objref_Port&);
    _objref_Port& operator = (const _objref_Port&);
    // not implemented

    friend class Port;
  };

  class _pof_Port : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_Port() : _OMNI_NS(proxyObjectFactory)(Port::_PD_repoId) {}
    virtual ~_pof_Port();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_Port :
    public virtual omniServant
  {
  public:
    virtual ~_impl_Port();

    virtual void connectPort(::CORBA::Object_ptr connection, const char* connectionId) = 0;
    virtual void disconnectPort(const char* connectionId) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Port;

#ifndef __CF_mLifeCycle__
#define __CF_mLifeCycle__
  class LifeCycle;
  class _objref_LifeCycle;
  class _impl_LifeCycle;
  
  typedef _objref_LifeCycle* LifeCycle_ptr;
  typedef LifeCycle_ptr LifeCycleRef;

  class LifeCycle_Helper {
  public:
    typedef LifeCycle_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_LifeCycle, LifeCycle_Helper> LifeCycle_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_LifeCycle,LifeCycle_Helper > LifeCycle_out;

#endif

  // interface LifeCycle
  class LifeCycle {
  public:
    // Declarations for this interface type.
    typedef LifeCycle_ptr _ptr_type;
    typedef LifeCycle_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    class InitializeError : public ::CORBA::UserException {
    public:
      
      StringSequence errorMessages;

    

      inline InitializeError() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      InitializeError(const InitializeError&);
      InitializeError(const StringSequence i_errorMessages);
      InitializeError& operator=(const InitializeError&);
      virtual ~InitializeError();
      virtual void _raise() const;
      static InitializeError* _downcast(::CORBA::Exception*);
      static const InitializeError* _downcast(const ::CORBA::Exception*);
      static inline InitializeError* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      void operator>>=(cdrStream&) const ;
      void operator<<=(cdrStream&) ;

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_InitializeError;

    class ReleaseError : public ::CORBA::UserException {
    public:
      
      StringSequence errorMessages;

    

      inline ReleaseError() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      ReleaseError(const ReleaseError&);
      ReleaseError(const StringSequence i_errorMessages);
      ReleaseError& operator=(const ReleaseError&);
      virtual ~ReleaseError();
      virtual void _raise() const;
      static ReleaseError* _downcast(::CORBA::Exception*);
      static const ReleaseError* _downcast(const ::CORBA::Exception*);
      static inline ReleaseError* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      void operator>>=(cdrStream&) const ;
      void operator<<=(cdrStream&) ;

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_ReleaseError;

  
  };

  class _objref_LifeCycle :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    // IDL operations
    void initialize();
    void releaseObject();

    // Constructors
    inline _objref_LifeCycle()  { _PR_setobj(0); }  // nil
    _objref_LifeCycle(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_LifeCycle();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_LifeCycle(const _objref_LifeCycle&);
    _objref_LifeCycle& operator = (const _objref_LifeCycle&);
    // not implemented

    friend class LifeCycle;
  };

  class _pof_LifeCycle : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_LifeCycle() : _OMNI_NS(proxyObjectFactory)(LifeCycle::_PD_repoId) {}
    virtual ~_pof_LifeCycle();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_LifeCycle :
    public virtual omniServant
  {
  public:
    virtual ~_impl_LifeCycle();

    virtual void initialize() = 0;
    virtual void releaseObject() = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_LifeCycle;

#ifndef __CF_mTestableObject__
#define __CF_mTestableObject__
  class TestableObject;
  class _objref_TestableObject;
  class _impl_TestableObject;
  
  typedef _objref_TestableObject* TestableObject_ptr;
  typedef TestableObject_ptr TestableObjectRef;

  class TestableObject_Helper {
  public:
    typedef TestableObject_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_TestableObject, TestableObject_Helper> TestableObject_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_TestableObject,TestableObject_Helper > TestableObject_out;

#endif

  // interface TestableObject
  class TestableObject {
  public:
    // Declarations for this interface type.
    typedef TestableObject_ptr _ptr_type;
    typedef TestableObject_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    class UnknownTest : public ::CORBA::UserException {
    public:
      
      

      inline UnknownTest() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      UnknownTest(const UnknownTest&);
      
      UnknownTest& operator=(const UnknownTest&);
      virtual ~UnknownTest();
      virtual void _raise() const;
      static UnknownTest* _downcast(::CORBA::Exception*);
      static const UnknownTest* _downcast(const ::CORBA::Exception*);
      static inline UnknownTest* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      inline void operator>>=(cdrStream&) const { }
      inline void operator<<=(cdrStream&) { }

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_UnknownTest;

  
  };

  class _objref_TestableObject :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    // IDL operations
    void runTest(::CORBA::ULong testid, ::CF::Properties& testValues);

    // Constructors
    inline _objref_TestableObject()  { _PR_setobj(0); }  // nil
    _objref_TestableObject(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_TestableObject();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_TestableObject(const _objref_TestableObject&);
    _objref_TestableObject& operator = (const _objref_TestableObject&);
    // not implemented

    friend class TestableObject;
  };

  class _pof_TestableObject : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_TestableObject() : _OMNI_NS(proxyObjectFactory)(TestableObject::_PD_repoId) {}
    virtual ~_pof_TestableObject();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_TestableObject :
    public virtual omniServant
  {
  public:
    virtual ~_impl_TestableObject();

    virtual void runTest(::CORBA::ULong testid, ::CF::Properties& testValues) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_TestableObject;

#ifndef __CF_mPropertySet__
#define __CF_mPropertySet__
  class PropertySet;
  class _objref_PropertySet;
  class _impl_PropertySet;
  
  typedef _objref_PropertySet* PropertySet_ptr;
  typedef PropertySet_ptr PropertySetRef;

  class PropertySet_Helper {
  public:
    typedef PropertySet_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_PropertySet, PropertySet_Helper> PropertySet_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_PropertySet,PropertySet_Helper > PropertySet_out;

#endif

  // interface PropertySet
  class PropertySet {
  public:
    // Declarations for this interface type.
    typedef PropertySet_ptr _ptr_type;
    typedef PropertySet_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    class InvalidConfiguration : public ::CORBA::UserException {
    public:
      
      ::CORBA::String_member msg;

      Properties invalidProperties;

    

      inline InvalidConfiguration() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      InvalidConfiguration(const InvalidConfiguration&);
      InvalidConfiguration(const char* i_msg, const Properties i_invalidProperties);
      InvalidConfiguration& operator=(const InvalidConfiguration&);
      virtual ~InvalidConfiguration();
      virtual void _raise() const;
      static InvalidConfiguration* _downcast(::CORBA::Exception*);
      static const InvalidConfiguration* _downcast(const ::CORBA::Exception*);
      static inline InvalidConfiguration* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      void operator>>=(cdrStream&) const ;
      void operator<<=(cdrStream&) ;

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_InvalidConfiguration;

    class PartialConfiguration : public ::CORBA::UserException {
    public:
      
      Properties invalidProperties;

    

      inline PartialConfiguration() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      PartialConfiguration(const PartialConfiguration&);
      PartialConfiguration(const Properties i_invalidProperties);
      PartialConfiguration& operator=(const PartialConfiguration&);
      virtual ~PartialConfiguration();
      virtual void _raise() const;
      static PartialConfiguration* _downcast(::CORBA::Exception*);
      static const PartialConfiguration* _downcast(const ::CORBA::Exception*);
      static inline PartialConfiguration* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      void operator>>=(cdrStream&) const ;
      void operator<<=(cdrStream&) ;

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_PartialConfiguration;

  
  };

  class _objref_PropertySet :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    // IDL operations
    void configure(const ::CF::Properties& configProperties);
    void query(::CF::Properties& configProperties);

    // Constructors
    inline _objref_PropertySet()  { _PR_setobj(0); }  // nil
    _objref_PropertySet(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_PropertySet();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_PropertySet(const _objref_PropertySet&);
    _objref_PropertySet& operator = (const _objref_PropertySet&);
    // not implemented

    friend class PropertySet;
  };

  class _pof_PropertySet : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_PropertySet() : _OMNI_NS(proxyObjectFactory)(PropertySet::_PD_repoId) {}
    virtual ~_pof_PropertySet();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_PropertySet :
    public virtual omniServant
  {
  public:
    virtual ~_impl_PropertySet();

    virtual void configure(const ::CF::Properties& configProperties) = 0;
    virtual void query(::CF::Properties& configProperties) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_PropertySet;

#ifndef __CF_mDomainManager__
#define __CF_mDomainManager__
  class DomainManager;
  class _objref_DomainManager;
  class _impl_DomainManager;
  
  typedef _objref_DomainManager* DomainManager_ptr;
  typedef DomainManager_ptr DomainManagerRef;

  class DomainManager_Helper {
  public:
    typedef DomainManager_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_DomainManager, DomainManager_Helper> DomainManager_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_DomainManager,DomainManager_Helper > DomainManager_out;

#endif

  // interface DomainManager
  class DomainManager {
  public:
    // Declarations for this interface type.
    typedef DomainManager_ptr _ptr_type;
    typedef DomainManager_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    class ApplicationInstallationError : public ::CORBA::UserException {
    public:
      
      ErrorNumberType errorNumber;

      ::CORBA::String_member msg;

    

      inline ApplicationInstallationError() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      ApplicationInstallationError(const ApplicationInstallationError&);
      ApplicationInstallationError(ErrorNumberType i_errorNumber, const char* i_msg);
      ApplicationInstallationError& operator=(const ApplicationInstallationError&);
      virtual ~ApplicationInstallationError();
      virtual void _raise() const;
      static ApplicationInstallationError* _downcast(::CORBA::Exception*);
      static const ApplicationInstallationError* _downcast(const ::CORBA::Exception*);
      static inline ApplicationInstallationError* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      void operator>>=(cdrStream&) const ;
      void operator<<=(cdrStream&) ;

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_ApplicationInstallationError;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_ApplicationSequence;

    class ApplicationSequence_var;

    class ApplicationSequence : public _CORBA_Unbounded_Sequence_ObjRef< _objref_Application, _CORBA_ObjRef_Element< _objref_Application, Application_Helper> , Application_Helper >  {
    public:
      typedef ApplicationSequence_var _var_type;
      inline ApplicationSequence() {}
      inline ApplicationSequence(const ApplicationSequence& _s)
        : _CORBA_Unbounded_Sequence_ObjRef< _objref_Application, _CORBA_ObjRef_Element< _objref_Application, Application_Helper> , Application_Helper > (_s) {}

      inline ApplicationSequence(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence_ObjRef< _objref_Application, _CORBA_ObjRef_Element< _objref_Application, Application_Helper> , Application_Helper > (_max) {}
      inline ApplicationSequence(_CORBA_ULong _max, _CORBA_ULong _len, Application_ptr* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence_ObjRef< _objref_Application, _CORBA_ObjRef_Element< _objref_Application, Application_Helper> , Application_Helper > (_max, _len, _val, _rel) {}

    

      inline ApplicationSequence& operator = (const ApplicationSequence& _s) {
        _CORBA_Unbounded_Sequence_ObjRef< _objref_Application, _CORBA_ObjRef_Element< _objref_Application, Application_Helper> , Application_Helper > ::operator=(_s);
        return *this;
      }
    };

    class ApplicationSequence_out;

    class ApplicationSequence_var {
    public:
      inline ApplicationSequence_var() : _pd_seq(0) {}
      inline ApplicationSequence_var(ApplicationSequence* _s) : _pd_seq(_s) {}
      inline ApplicationSequence_var(const ApplicationSequence_var& _s) {
        if (_s._pd_seq)  _pd_seq = new ApplicationSequence(*_s._pd_seq);
        else             _pd_seq = 0;
      }
      inline ~ApplicationSequence_var() { if (_pd_seq)  delete _pd_seq; }
        
      inline ApplicationSequence_var& operator = (ApplicationSequence* _s) {
        if (_pd_seq)  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline ApplicationSequence_var& operator = (const ApplicationSequence_var& _s) {
        if (&_s != this) {
          if (_s._pd_seq) {
            if (!_pd_seq)  _pd_seq = new ApplicationSequence;
            *_pd_seq = *_s._pd_seq;
          }
          else if (_pd_seq) {
            delete _pd_seq;
            _pd_seq = 0;
          }
        }
        return *this;
      }
      inline _CORBA_ObjRef_Element< _objref_Application, Application_Helper>  operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline ApplicationSequence* operator -> () { return _pd_seq; }
      inline const ApplicationSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator ApplicationSequence& () const { return *_pd_seq; }
#else
      inline operator const ApplicationSequence& () const { return *_pd_seq; }
      inline operator ApplicationSequence& () { return *_pd_seq; }
#endif
        
      inline const ApplicationSequence& in() const { return *_pd_seq; }
      inline ApplicationSequence&       inout()    { return *_pd_seq; }
      inline ApplicationSequence*&      out() {
        if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline ApplicationSequence* _retn() { ApplicationSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class ApplicationSequence_out;
      
    private:
      ApplicationSequence* _pd_seq;
    };

    class ApplicationSequence_out {
    public:
      inline ApplicationSequence_out(ApplicationSequence*& _s) : _data(_s) { _data = 0; }
      inline ApplicationSequence_out(ApplicationSequence_var& _s)
        : _data(_s._pd_seq) { _s = (ApplicationSequence*) 0; }
      inline ApplicationSequence_out(const ApplicationSequence_out& _s) : _data(_s._data) {}
      inline ApplicationSequence_out& operator = (const ApplicationSequence_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline ApplicationSequence_out& operator = (ApplicationSequence* _s) {
        _data = _s;
        return *this;
      }
      inline operator ApplicationSequence*&()  { return _data; }
      inline ApplicationSequence*& ptr()       { return _data; }
      inline ApplicationSequence* operator->() { return _data; }

      inline _CORBA_ObjRef_Element< _objref_Application, Application_Helper>  operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      ApplicationSequence*& _data;

    private:
      ApplicationSequence_out();
      ApplicationSequence_out& operator=(const ApplicationSequence_var&);
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_ApplicationFactorySequence;

    class ApplicationFactorySequence_var;

    class ApplicationFactorySequence : public _CORBA_Unbounded_Sequence_ObjRef< _objref_ApplicationFactory, _CORBA_ObjRef_Element< _objref_ApplicationFactory, ApplicationFactory_Helper> , ApplicationFactory_Helper >  {
    public:
      typedef ApplicationFactorySequence_var _var_type;
      inline ApplicationFactorySequence() {}
      inline ApplicationFactorySequence(const ApplicationFactorySequence& _s)
        : _CORBA_Unbounded_Sequence_ObjRef< _objref_ApplicationFactory, _CORBA_ObjRef_Element< _objref_ApplicationFactory, ApplicationFactory_Helper> , ApplicationFactory_Helper > (_s) {}

      inline ApplicationFactorySequence(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence_ObjRef< _objref_ApplicationFactory, _CORBA_ObjRef_Element< _objref_ApplicationFactory, ApplicationFactory_Helper> , ApplicationFactory_Helper > (_max) {}
      inline ApplicationFactorySequence(_CORBA_ULong _max, _CORBA_ULong _len, ApplicationFactory_ptr* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence_ObjRef< _objref_ApplicationFactory, _CORBA_ObjRef_Element< _objref_ApplicationFactory, ApplicationFactory_Helper> , ApplicationFactory_Helper > (_max, _len, _val, _rel) {}

    

      inline ApplicationFactorySequence& operator = (const ApplicationFactorySequence& _s) {
        _CORBA_Unbounded_Sequence_ObjRef< _objref_ApplicationFactory, _CORBA_ObjRef_Element< _objref_ApplicationFactory, ApplicationFactory_Helper> , ApplicationFactory_Helper > ::operator=(_s);
        return *this;
      }
    };

    class ApplicationFactorySequence_out;

    class ApplicationFactorySequence_var {
    public:
      inline ApplicationFactorySequence_var() : _pd_seq(0) {}
      inline ApplicationFactorySequence_var(ApplicationFactorySequence* _s) : _pd_seq(_s) {}
      inline ApplicationFactorySequence_var(const ApplicationFactorySequence_var& _s) {
        if (_s._pd_seq)  _pd_seq = new ApplicationFactorySequence(*_s._pd_seq);
        else             _pd_seq = 0;
      }
      inline ~ApplicationFactorySequence_var() { if (_pd_seq)  delete _pd_seq; }
        
      inline ApplicationFactorySequence_var& operator = (ApplicationFactorySequence* _s) {
        if (_pd_seq)  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline ApplicationFactorySequence_var& operator = (const ApplicationFactorySequence_var& _s) {
        if (&_s != this) {
          if (_s._pd_seq) {
            if (!_pd_seq)  _pd_seq = new ApplicationFactorySequence;
            *_pd_seq = *_s._pd_seq;
          }
          else if (_pd_seq) {
            delete _pd_seq;
            _pd_seq = 0;
          }
        }
        return *this;
      }
      inline _CORBA_ObjRef_Element< _objref_ApplicationFactory, ApplicationFactory_Helper>  operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline ApplicationFactorySequence* operator -> () { return _pd_seq; }
      inline const ApplicationFactorySequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator ApplicationFactorySequence& () const { return *_pd_seq; }
#else
      inline operator const ApplicationFactorySequence& () const { return *_pd_seq; }
      inline operator ApplicationFactorySequence& () { return *_pd_seq; }
#endif
        
      inline const ApplicationFactorySequence& in() const { return *_pd_seq; }
      inline ApplicationFactorySequence&       inout()    { return *_pd_seq; }
      inline ApplicationFactorySequence*&      out() {
        if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline ApplicationFactorySequence* _retn() { ApplicationFactorySequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class ApplicationFactorySequence_out;
      
    private:
      ApplicationFactorySequence* _pd_seq;
    };

    class ApplicationFactorySequence_out {
    public:
      inline ApplicationFactorySequence_out(ApplicationFactorySequence*& _s) : _data(_s) { _data = 0; }
      inline ApplicationFactorySequence_out(ApplicationFactorySequence_var& _s)
        : _data(_s._pd_seq) { _s = (ApplicationFactorySequence*) 0; }
      inline ApplicationFactorySequence_out(const ApplicationFactorySequence_out& _s) : _data(_s._data) {}
      inline ApplicationFactorySequence_out& operator = (const ApplicationFactorySequence_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline ApplicationFactorySequence_out& operator = (ApplicationFactorySequence* _s) {
        _data = _s;
        return *this;
      }
      inline operator ApplicationFactorySequence*&()  { return _data; }
      inline ApplicationFactorySequence*& ptr()       { return _data; }
      inline ApplicationFactorySequence* operator->() { return _data; }

      inline _CORBA_ObjRef_Element< _objref_ApplicationFactory, ApplicationFactory_Helper>  operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      ApplicationFactorySequence*& _data;

    private:
      ApplicationFactorySequence_out();
      ApplicationFactorySequence_out& operator=(const ApplicationFactorySequence_var&);
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_DeviceManagerSequence;

    class DeviceManagerSequence_var;

    class DeviceManagerSequence : public _CORBA_Unbounded_Sequence_ObjRef< _objref_DeviceManager, _CORBA_ObjRef_Element< _objref_DeviceManager, DeviceManager_Helper> , DeviceManager_Helper >  {
    public:
      typedef DeviceManagerSequence_var _var_type;
      inline DeviceManagerSequence() {}
      inline DeviceManagerSequence(const DeviceManagerSequence& _s)
        : _CORBA_Unbounded_Sequence_ObjRef< _objref_DeviceManager, _CORBA_ObjRef_Element< _objref_DeviceManager, DeviceManager_Helper> , DeviceManager_Helper > (_s) {}

      inline DeviceManagerSequence(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence_ObjRef< _objref_DeviceManager, _CORBA_ObjRef_Element< _objref_DeviceManager, DeviceManager_Helper> , DeviceManager_Helper > (_max) {}
      inline DeviceManagerSequence(_CORBA_ULong _max, _CORBA_ULong _len, DeviceManager_ptr* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence_ObjRef< _objref_DeviceManager, _CORBA_ObjRef_Element< _objref_DeviceManager, DeviceManager_Helper> , DeviceManager_Helper > (_max, _len, _val, _rel) {}

    

      inline DeviceManagerSequence& operator = (const DeviceManagerSequence& _s) {
        _CORBA_Unbounded_Sequence_ObjRef< _objref_DeviceManager, _CORBA_ObjRef_Element< _objref_DeviceManager, DeviceManager_Helper> , DeviceManager_Helper > ::operator=(_s);
        return *this;
      }
    };

    class DeviceManagerSequence_out;

    class DeviceManagerSequence_var {
    public:
      inline DeviceManagerSequence_var() : _pd_seq(0) {}
      inline DeviceManagerSequence_var(DeviceManagerSequence* _s) : _pd_seq(_s) {}
      inline DeviceManagerSequence_var(const DeviceManagerSequence_var& _s) {
        if (_s._pd_seq)  _pd_seq = new DeviceManagerSequence(*_s._pd_seq);
        else             _pd_seq = 0;
      }
      inline ~DeviceManagerSequence_var() { if (_pd_seq)  delete _pd_seq; }
        
      inline DeviceManagerSequence_var& operator = (DeviceManagerSequence* _s) {
        if (_pd_seq)  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline DeviceManagerSequence_var& operator = (const DeviceManagerSequence_var& _s) {
        if (&_s != this) {
          if (_s._pd_seq) {
            if (!_pd_seq)  _pd_seq = new DeviceManagerSequence;
            *_pd_seq = *_s._pd_seq;
          }
          else if (_pd_seq) {
            delete _pd_seq;
            _pd_seq = 0;
          }
        }
        return *this;
      }
      inline _CORBA_ObjRef_Element< _objref_DeviceManager, DeviceManager_Helper>  operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline DeviceManagerSequence* operator -> () { return _pd_seq; }
      inline const DeviceManagerSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator DeviceManagerSequence& () const { return *_pd_seq; }
#else
      inline operator const DeviceManagerSequence& () const { return *_pd_seq; }
      inline operator DeviceManagerSequence& () { return *_pd_seq; }
#endif
        
      inline const DeviceManagerSequence& in() const { return *_pd_seq; }
      inline DeviceManagerSequence&       inout()    { return *_pd_seq; }
      inline DeviceManagerSequence*&      out() {
        if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline DeviceManagerSequence* _retn() { DeviceManagerSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class DeviceManagerSequence_out;
      
    private:
      DeviceManagerSequence* _pd_seq;
    };

    class DeviceManagerSequence_out {
    public:
      inline DeviceManagerSequence_out(DeviceManagerSequence*& _s) : _data(_s) { _data = 0; }
      inline DeviceManagerSequence_out(DeviceManagerSequence_var& _s)
        : _data(_s._pd_seq) { _s = (DeviceManagerSequence*) 0; }
      inline DeviceManagerSequence_out(const DeviceManagerSequence_out& _s) : _data(_s._data) {}
      inline DeviceManagerSequence_out& operator = (const DeviceManagerSequence_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline DeviceManagerSequence_out& operator = (DeviceManagerSequence* _s) {
        _data = _s;
        return *this;
      }
      inline operator DeviceManagerSequence*&()  { return _data; }
      inline DeviceManagerSequence*& ptr()       { return _data; }
      inline DeviceManagerSequence* operator->() { return _data; }

      inline _CORBA_ObjRef_Element< _objref_DeviceManager, DeviceManager_Helper>  operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      DeviceManagerSequence*& _data;

    private:
      DeviceManagerSequence_out();
      DeviceManagerSequence_out& operator=(const DeviceManagerSequence_var&);
    };

    class InvalidIdentifier : public ::CORBA::UserException {
    public:
      
      

      inline InvalidIdentifier() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      InvalidIdentifier(const InvalidIdentifier&);
      
      InvalidIdentifier& operator=(const InvalidIdentifier&);
      virtual ~InvalidIdentifier();
      virtual void _raise() const;
      static InvalidIdentifier* _downcast(::CORBA::Exception*);
      static const InvalidIdentifier* _downcast(const ::CORBA::Exception*);
      static inline InvalidIdentifier* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      inline void operator>>=(cdrStream&) const { }
      inline void operator<<=(cdrStream&) { }

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_InvalidIdentifier;

    class DeviceManagerNotRegistered : public ::CORBA::UserException {
    public:
      
      

      inline DeviceManagerNotRegistered() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      DeviceManagerNotRegistered(const DeviceManagerNotRegistered&);
      
      DeviceManagerNotRegistered& operator=(const DeviceManagerNotRegistered&);
      virtual ~DeviceManagerNotRegistered();
      virtual void _raise() const;
      static DeviceManagerNotRegistered* _downcast(::CORBA::Exception*);
      static const DeviceManagerNotRegistered* _downcast(const ::CORBA::Exception*);
      static inline DeviceManagerNotRegistered* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      inline void operator>>=(cdrStream&) const { }
      inline void operator<<=(cdrStream&) { }

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_DeviceManagerNotRegistered;

    class ApplicationUninstallationError : public ::CORBA::UserException {
    public:
      
      ErrorNumberType errorNumber;

      ::CORBA::String_member msg;

    

      inline ApplicationUninstallationError() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      ApplicationUninstallationError(const ApplicationUninstallationError&);
      ApplicationUninstallationError(ErrorNumberType i_errorNumber, const char* i_msg);
      ApplicationUninstallationError& operator=(const ApplicationUninstallationError&);
      virtual ~ApplicationUninstallationError();
      virtual void _raise() const;
      static ApplicationUninstallationError* _downcast(::CORBA::Exception*);
      static const ApplicationUninstallationError* _downcast(const ::CORBA::Exception*);
      static inline ApplicationUninstallationError* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      void operator>>=(cdrStream&) const ;
      void operator<<=(cdrStream&) ;

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_ApplicationUninstallationError;

    class RegisterError : public ::CORBA::UserException {
    public:
      
      ErrorNumberType errorNumber;

      ::CORBA::String_member msg;

    

      inline RegisterError() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      RegisterError(const RegisterError&);
      RegisterError(ErrorNumberType i_errorNumber, const char* i_msg);
      RegisterError& operator=(const RegisterError&);
      virtual ~RegisterError();
      virtual void _raise() const;
      static RegisterError* _downcast(::CORBA::Exception*);
      static const RegisterError* _downcast(const ::CORBA::Exception*);
      static inline RegisterError* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      void operator>>=(cdrStream&) const ;
      void operator<<=(cdrStream&) ;

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_RegisterError;

    class UnregisterError : public ::CORBA::UserException {
    public:
      
      ErrorNumberType errorNumber;

      ::CORBA::String_member msg;

    

      inline UnregisterError() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      UnregisterError(const UnregisterError&);
      UnregisterError(ErrorNumberType i_errorNumber, const char* i_msg);
      UnregisterError& operator=(const UnregisterError&);
      virtual ~UnregisterError();
      virtual void _raise() const;
      static UnregisterError* _downcast(::CORBA::Exception*);
      static const UnregisterError* _downcast(const ::CORBA::Exception*);
      static inline UnregisterError* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      void operator>>=(cdrStream&) const ;
      void operator<<=(cdrStream&) ;

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_UnregisterError;

    class AlreadyConnected : public ::CORBA::UserException {
    public:
      
      

      inline AlreadyConnected() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      AlreadyConnected(const AlreadyConnected&);
      
      AlreadyConnected& operator=(const AlreadyConnected&);
      virtual ~AlreadyConnected();
      virtual void _raise() const;
      static AlreadyConnected* _downcast(::CORBA::Exception*);
      static const AlreadyConnected* _downcast(const ::CORBA::Exception*);
      static inline AlreadyConnected* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      inline void operator>>=(cdrStream&) const { }
      inline void operator<<=(cdrStream&) { }

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_AlreadyConnected;

    class InvalidEventChannelName : public ::CORBA::UserException {
    public:
      
      

      inline InvalidEventChannelName() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      InvalidEventChannelName(const InvalidEventChannelName&);
      
      InvalidEventChannelName& operator=(const InvalidEventChannelName&);
      virtual ~InvalidEventChannelName();
      virtual void _raise() const;
      static InvalidEventChannelName* _downcast(::CORBA::Exception*);
      static const InvalidEventChannelName* _downcast(const ::CORBA::Exception*);
      static inline InvalidEventChannelName* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      inline void operator>>=(cdrStream&) const { }
      inline void operator<<=(cdrStream&) { }

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_InvalidEventChannelName;

    class NotConnected : public ::CORBA::UserException {
    public:
      
      

      inline NotConnected() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      NotConnected(const NotConnected&);
      
      NotConnected& operator=(const NotConnected&);
      virtual ~NotConnected();
      virtual void _raise() const;
      static NotConnected* _downcast(::CORBA::Exception*);
      static const NotConnected* _downcast(const ::CORBA::Exception*);
      static inline NotConnected* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      inline void operator>>=(cdrStream&) const { }
      inline void operator<<=(cdrStream&) { }

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_NotConnected;

  
  };

  class _objref_DomainManager :
    public virtual _objref_PropertySet
  {
  public:
    // IDL operations
    char* domainManagerProfile();
    DomainManager::DeviceManagerSequence* deviceManagers();
    DomainManager::ApplicationSequence* applications();
    DomainManager::ApplicationFactorySequence* applicationFactories();
    FileManager_ptr fileMgr();
    char* identifier();
    void registerDevice(::CF::Device_ptr registeringDevice, ::CF::DeviceManager_ptr registeredDeviceMgr);
    void registerDeviceManager(::CF::DeviceManager_ptr deviceMgr);
    void unregisterDeviceManager(::CF::DeviceManager_ptr deviceMgr);
    void unregisterDevice(::CF::Device_ptr unregisteringDevice);
    void installApplication(const char* profileFileName);
    void uninstallApplication(const char* applicationId);
    void registerService(::CORBA::Object_ptr registeringService, ::CF::DeviceManager_ptr registeredDeviceMgr, const char* name);
    void unregisterService(::CORBA::Object_ptr unregisteringService, const char* name);
    void registerWithEventChannel(::CORBA::Object_ptr registeringObject, const char* registeringId, const char* eventChannelName);
    void unregisterFromEventChannel(const char* unregisteringId, const char* eventChannelName);

    // Constructors
    inline _objref_DomainManager()  { _PR_setobj(0); }  // nil
    _objref_DomainManager(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_DomainManager();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_DomainManager(const _objref_DomainManager&);
    _objref_DomainManager& operator = (const _objref_DomainManager&);
    // not implemented

    friend class DomainManager;
  };

  class _pof_DomainManager : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_DomainManager() : _OMNI_NS(proxyObjectFactory)(DomainManager::_PD_repoId) {}
    virtual ~_pof_DomainManager();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_DomainManager :
    public virtual _impl_PropertySet
  {
  public:
    virtual ~_impl_DomainManager();

    virtual char* domainManagerProfile() = 0;
    virtual DomainManager::DeviceManagerSequence* deviceManagers() = 0;
    virtual DomainManager::ApplicationSequence* applications() = 0;
    virtual DomainManager::ApplicationFactorySequence* applicationFactories() = 0;
    virtual FileManager_ptr fileMgr() = 0;
    virtual char* identifier() = 0;
    virtual void registerDevice(::CF::Device_ptr registeringDevice, ::CF::DeviceManager_ptr registeredDeviceMgr) = 0;
    virtual void registerDeviceManager(::CF::DeviceManager_ptr deviceMgr) = 0;
    virtual void unregisterDeviceManager(::CF::DeviceManager_ptr deviceMgr) = 0;
    virtual void unregisterDevice(::CF::Device_ptr unregisteringDevice) = 0;
    virtual void installApplication(const char* profileFileName) = 0;
    virtual void uninstallApplication(const char* applicationId) = 0;
    virtual void registerService(::CORBA::Object_ptr registeringService, ::CF::DeviceManager_ptr registeredDeviceMgr, const char* name) = 0;
    virtual void unregisterService(::CORBA::Object_ptr unregisteringService, const char* name) = 0;
    virtual void registerWithEventChannel(::CORBA::Object_ptr registeringObject, const char* registeringId, const char* eventChannelName) = 0;
    virtual void unregisterFromEventChannel(const char* unregisteringId, const char* eventChannelName) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_DomainManager;

#ifndef __CF_mApplicationFactory__
#define __CF_mApplicationFactory__
  class ApplicationFactory;
  class _objref_ApplicationFactory;
  class _impl_ApplicationFactory;
  
  typedef _objref_ApplicationFactory* ApplicationFactory_ptr;
  typedef ApplicationFactory_ptr ApplicationFactoryRef;

  class ApplicationFactory_Helper {
  public:
    typedef ApplicationFactory_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_ApplicationFactory, ApplicationFactory_Helper> ApplicationFactory_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_ApplicationFactory,ApplicationFactory_Helper > ApplicationFactory_out;

#endif

  // interface ApplicationFactory
  class ApplicationFactory {
  public:
    // Declarations for this interface type.
    typedef ApplicationFactory_ptr _ptr_type;
    typedef ApplicationFactory_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    class CreateApplicationRequestError : public ::CORBA::UserException {
    public:
      
      DeviceAssignmentSequence invalidAssignments;

    

      inline CreateApplicationRequestError() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      CreateApplicationRequestError(const CreateApplicationRequestError&);
      CreateApplicationRequestError(const DeviceAssignmentSequence i_invalidAssignments);
      CreateApplicationRequestError& operator=(const CreateApplicationRequestError&);
      virtual ~CreateApplicationRequestError();
      virtual void _raise() const;
      static CreateApplicationRequestError* _downcast(::CORBA::Exception*);
      static const CreateApplicationRequestError* _downcast(const ::CORBA::Exception*);
      static inline CreateApplicationRequestError* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      void operator>>=(cdrStream&) const ;
      void operator<<=(cdrStream&) ;

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_CreateApplicationRequestError;

    class CreateApplicationError : public ::CORBA::UserException {
    public:
      
      ErrorNumberType errorNumber;

      ::CORBA::String_member msg;

    

      inline CreateApplicationError() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      CreateApplicationError(const CreateApplicationError&);
      CreateApplicationError(ErrorNumberType i_errorNumber, const char* i_msg);
      CreateApplicationError& operator=(const CreateApplicationError&);
      virtual ~CreateApplicationError();
      virtual void _raise() const;
      static CreateApplicationError* _downcast(::CORBA::Exception*);
      static const CreateApplicationError* _downcast(const ::CORBA::Exception*);
      static inline CreateApplicationError* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      void operator>>=(cdrStream&) const ;
      void operator<<=(cdrStream&) ;

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_CreateApplicationError;

    class InvalidInitConfiguration : public ::CORBA::UserException {
    public:
      
      Properties invalidProperties;

    

      inline InvalidInitConfiguration() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      InvalidInitConfiguration(const InvalidInitConfiguration&);
      InvalidInitConfiguration(const Properties i_invalidProperties);
      InvalidInitConfiguration& operator=(const InvalidInitConfiguration&);
      virtual ~InvalidInitConfiguration();
      virtual void _raise() const;
      static InvalidInitConfiguration* _downcast(::CORBA::Exception*);
      static const InvalidInitConfiguration* _downcast(const ::CORBA::Exception*);
      static inline InvalidInitConfiguration* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      void operator>>=(cdrStream&) const ;
      void operator<<=(cdrStream&) ;

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_InvalidInitConfiguration;

  
  };

  class _objref_ApplicationFactory :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    // IDL operations
    char* name();
    char* identifier();
    char* softwareProfile();
    Application_ptr create(const char* name, const ::CF::Properties& initConfiguration, const ::CF::DeviceAssignmentSequence& deviceAssignments);

    // Constructors
    inline _objref_ApplicationFactory()  { _PR_setobj(0); }  // nil
    _objref_ApplicationFactory(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_ApplicationFactory();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_ApplicationFactory(const _objref_ApplicationFactory&);
    _objref_ApplicationFactory& operator = (const _objref_ApplicationFactory&);
    // not implemented

    friend class ApplicationFactory;
  };

  class _pof_ApplicationFactory : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_ApplicationFactory() : _OMNI_NS(proxyObjectFactory)(ApplicationFactory::_PD_repoId) {}
    virtual ~_pof_ApplicationFactory();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_ApplicationFactory :
    public virtual omniServant
  {
  public:
    virtual ~_impl_ApplicationFactory();

    virtual char* name() = 0;
    virtual char* identifier() = 0;
    virtual char* softwareProfile() = 0;
    virtual Application_ptr create(const char* name, const ::CF::Properties& initConfiguration, const ::CF::DeviceAssignmentSequence& deviceAssignments) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ApplicationFactory;

#ifndef __CF_mPortSupplier__
#define __CF_mPortSupplier__
  class PortSupplier;
  class _objref_PortSupplier;
  class _impl_PortSupplier;
  
  typedef _objref_PortSupplier* PortSupplier_ptr;
  typedef PortSupplier_ptr PortSupplierRef;

  class PortSupplier_Helper {
  public:
    typedef PortSupplier_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_PortSupplier, PortSupplier_Helper> PortSupplier_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_PortSupplier,PortSupplier_Helper > PortSupplier_out;

#endif

  // interface PortSupplier
  class PortSupplier {
  public:
    // Declarations for this interface type.
    typedef PortSupplier_ptr _ptr_type;
    typedef PortSupplier_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    class UnknownPort : public ::CORBA::UserException {
    public:
      
      

      inline UnknownPort() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      UnknownPort(const UnknownPort&);
      
      UnknownPort& operator=(const UnknownPort&);
      virtual ~UnknownPort();
      virtual void _raise() const;
      static UnknownPort* _downcast(::CORBA::Exception*);
      static const UnknownPort* _downcast(const ::CORBA::Exception*);
      static inline UnknownPort* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      inline void operator>>=(cdrStream&) const { }
      inline void operator<<=(cdrStream&) { }

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_UnknownPort;

  
  };

  class _objref_PortSupplier :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    // IDL operations
    ::CORBA::Object_ptr getPort(const char* name);

    // Constructors
    inline _objref_PortSupplier()  { _PR_setobj(0); }  // nil
    _objref_PortSupplier(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_PortSupplier();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_PortSupplier(const _objref_PortSupplier&);
    _objref_PortSupplier& operator = (const _objref_PortSupplier&);
    // not implemented

    friend class PortSupplier;
  };

  class _pof_PortSupplier : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_PortSupplier() : _OMNI_NS(proxyObjectFactory)(PortSupplier::_PD_repoId) {}
    virtual ~_pof_PortSupplier();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_PortSupplier :
    public virtual omniServant
  {
  public:
    virtual ~_impl_PortSupplier();

    virtual ::CORBA::Object_ptr getPort(const char* name) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_PortSupplier;

#ifndef __CF_mResource__
#define __CF_mResource__
  class Resource;
  class _objref_Resource;
  class _impl_Resource;
  
  typedef _objref_Resource* Resource_ptr;
  typedef Resource_ptr ResourceRef;

  class Resource_Helper {
  public:
    typedef Resource_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_Resource, Resource_Helper> Resource_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_Resource,Resource_Helper > Resource_out;

#endif

  // interface Resource
  class Resource {
  public:
    // Declarations for this interface type.
    typedef Resource_ptr _ptr_type;
    typedef Resource_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    class StartError : public ::CORBA::UserException {
    public:
      
      ErrorNumberType errorNumber;

      ::CORBA::String_member msg;

    

      inline StartError() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      StartError(const StartError&);
      StartError(ErrorNumberType i_errorNumber, const char* i_msg);
      StartError& operator=(const StartError&);
      virtual ~StartError();
      virtual void _raise() const;
      static StartError* _downcast(::CORBA::Exception*);
      static const StartError* _downcast(const ::CORBA::Exception*);
      static inline StartError* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      void operator>>=(cdrStream&) const ;
      void operator<<=(cdrStream&) ;

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_StartError;

    class StopError : public ::CORBA::UserException {
    public:
      
      ErrorNumberType errorNumber;

      ::CORBA::String_member msg;

    

      inline StopError() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      StopError(const StopError&);
      StopError(ErrorNumberType i_errorNumber, const char* i_msg);
      StopError& operator=(const StopError&);
      virtual ~StopError();
      virtual void _raise() const;
      static StopError* _downcast(::CORBA::Exception*);
      static const StopError* _downcast(const ::CORBA::Exception*);
      static inline StopError* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      void operator>>=(cdrStream&) const ;
      void operator<<=(cdrStream&) ;

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_StopError;

  
  };

  class _objref_Resource :
    public virtual _objref_LifeCycle,
    public virtual _objref_TestableObject,
    public virtual _objref_PropertySet,
    public virtual _objref_PortSupplier
  {
  public:
    // IDL operations
    char* identifier();
    void start();
    void stop();

    // Constructors
    inline _objref_Resource()  { _PR_setobj(0); }  // nil
    _objref_Resource(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_Resource();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_Resource(const _objref_Resource&);
    _objref_Resource& operator = (const _objref_Resource&);
    // not implemented

    friend class Resource;
  };

  class _pof_Resource : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_Resource() : _OMNI_NS(proxyObjectFactory)(Resource::_PD_repoId) {}
    virtual ~_pof_Resource();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_Resource :
    public virtual _impl_LifeCycle,
    public virtual _impl_TestableObject,
    public virtual _impl_PropertySet,
    public virtual _impl_PortSupplier
  {
  public:
    virtual ~_impl_Resource();

    virtual char* identifier() = 0;
    virtual void start() = 0;
    virtual void stop() = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Resource;

#ifndef __CF_mDevice__
#define __CF_mDevice__
  class Device;
  class _objref_Device;
  class _impl_Device;
  
  typedef _objref_Device* Device_ptr;
  typedef Device_ptr DeviceRef;

  class Device_Helper {
  public:
    typedef Device_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_Device, Device_Helper> Device_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_Device,Device_Helper > Device_out;

#endif

  // interface Device
  class Device {
  public:
    // Declarations for this interface type.
    typedef Device_ptr _ptr_type;
    typedef Device_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    class InvalidState : public ::CORBA::UserException {
    public:
      
      ::CORBA::String_member msg;

    

      inline InvalidState() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      InvalidState(const InvalidState&);
      InvalidState(const char* i_msg);
      InvalidState& operator=(const InvalidState&);
      virtual ~InvalidState();
      virtual void _raise() const;
      static InvalidState* _downcast(::CORBA::Exception*);
      static const InvalidState* _downcast(const ::CORBA::Exception*);
      static inline InvalidState* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      void operator>>=(cdrStream&) const ;
      void operator<<=(cdrStream&) ;

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_InvalidState;

    class InvalidCapacity : public ::CORBA::UserException {
    public:
      
      ::CORBA::String_member msg;

      Properties capacities;

    

      inline InvalidCapacity() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      InvalidCapacity(const InvalidCapacity&);
      InvalidCapacity(const char* i_msg, const Properties i_capacities);
      InvalidCapacity& operator=(const InvalidCapacity&);
      virtual ~InvalidCapacity();
      virtual void _raise() const;
      static InvalidCapacity* _downcast(::CORBA::Exception*);
      static const InvalidCapacity* _downcast(const ::CORBA::Exception*);
      static inline InvalidCapacity* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      void operator>>=(cdrStream&) const ;
      void operator<<=(cdrStream&) ;

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_InvalidCapacity;

    enum AdminType { LOCKED, SHUTTING_DOWN, UNLOCKED /*, __max_AdminType=0xffffffff */ };
    typedef AdminType& AdminType_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_AdminType;

    enum OperationalType { ENABLED, DISABLED /*, __max_OperationalType=0xffffffff */ };
    typedef OperationalType& OperationalType_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_OperationalType;

    enum UsageType { IDLE, ACTIVE, BUSY /*, __max_UsageType=0xffffffff */ };
    typedef UsageType& UsageType_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_UsageType;

  
  };

  class _objref_Device :
    public virtual _objref_Resource
  {
  public:
    // IDL operations
    Device::UsageType usageState();
    Device::AdminType adminState();
    void adminState(::CF::Device::AdminType _v);
    Device::OperationalType operationalState();
    char* softwareProfile();
    char* label();
    AggregateDevice_ptr compositeDevice();
    ::CORBA::Boolean allocateCapacity(const ::CF::Properties& capacities);
    void deallocateCapacity(const ::CF::Properties& capacities);

    // Constructors
    inline _objref_Device()  { _PR_setobj(0); }  // nil
    _objref_Device(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_Device();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_Device(const _objref_Device&);
    _objref_Device& operator = (const _objref_Device&);
    // not implemented

    friend class Device;
  };

  class _pof_Device : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_Device() : _OMNI_NS(proxyObjectFactory)(Device::_PD_repoId) {}
    virtual ~_pof_Device();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_Device :
    public virtual _impl_Resource
  {
  public:
    virtual ~_impl_Device();

    virtual Device::UsageType usageState() = 0;
    virtual Device::AdminType adminState() = 0;
    virtual void adminState(::CF::Device::AdminType _v) = 0;
    virtual Device::OperationalType operationalState() = 0;
    virtual char* softwareProfile() = 0;
    virtual char* label() = 0;
    virtual AggregateDevice_ptr compositeDevice() = 0;
    virtual ::CORBA::Boolean allocateCapacity(const ::CF::Properties& capacities) = 0;
    virtual void deallocateCapacity(const ::CF::Properties& capacities) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Device;

#ifndef __CF_mApplication__
#define __CF_mApplication__
  class Application;
  class _objref_Application;
  class _impl_Application;
  
  typedef _objref_Application* Application_ptr;
  typedef Application_ptr ApplicationRef;

  class Application_Helper {
  public:
    typedef Application_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_Application, Application_Helper> Application_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_Application,Application_Helper > Application_out;

#endif

  // interface Application
  class Application {
  public:
    // Declarations for this interface type.
    typedef Application_ptr _ptr_type;
    typedef Application_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    struct ComponentProcessIdType {
      typedef _CORBA_ConstrType_Variable_Var<ComponentProcessIdType> _var_type;

      
      ::CORBA::String_member componentId;

      ::CORBA::ULong processId;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef ComponentProcessIdType::_var_type ComponentProcessIdType_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< ComponentProcessIdType,ComponentProcessIdType_var > ComponentProcessIdType_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_ComponentProcessIdType;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_ComponentProcessIdSequence;

    class ComponentProcessIdSequence_var;

    class ComponentProcessIdSequence : public _CORBA_Unbounded_Sequence< ComponentProcessIdType >  {
    public:
      typedef ComponentProcessIdSequence_var _var_type;
      inline ComponentProcessIdSequence() {}
      inline ComponentProcessIdSequence(const ComponentProcessIdSequence& _s)
        : _CORBA_Unbounded_Sequence< ComponentProcessIdType > (_s) {}

      inline ComponentProcessIdSequence(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence< ComponentProcessIdType > (_max) {}
      inline ComponentProcessIdSequence(_CORBA_ULong _max, _CORBA_ULong _len, ComponentProcessIdType* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence< ComponentProcessIdType > (_max, _len, _val, _rel) {}

    

      inline ComponentProcessIdSequence& operator = (const ComponentProcessIdSequence& _s) {
        _CORBA_Unbounded_Sequence< ComponentProcessIdType > ::operator=(_s);
        return *this;
      }
    };

    class ComponentProcessIdSequence_out;

    class ComponentProcessIdSequence_var {
    public:
      inline ComponentProcessIdSequence_var() : _pd_seq(0) {}
      inline ComponentProcessIdSequence_var(ComponentProcessIdSequence* _s) : _pd_seq(_s) {}
      inline ComponentProcessIdSequence_var(const ComponentProcessIdSequence_var& _s) {
        if (_s._pd_seq)  _pd_seq = new ComponentProcessIdSequence(*_s._pd_seq);
        else             _pd_seq = 0;
      }
      inline ~ComponentProcessIdSequence_var() { if (_pd_seq)  delete _pd_seq; }
        
      inline ComponentProcessIdSequence_var& operator = (ComponentProcessIdSequence* _s) {
        if (_pd_seq)  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline ComponentProcessIdSequence_var& operator = (const ComponentProcessIdSequence_var& _s) {
        if (&_s != this) {
          if (_s._pd_seq) {
            if (!_pd_seq)  _pd_seq = new ComponentProcessIdSequence;
            *_pd_seq = *_s._pd_seq;
          }
          else if (_pd_seq) {
            delete _pd_seq;
            _pd_seq = 0;
          }
        }
        return *this;
      }
      inline ComponentProcessIdType& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline ComponentProcessIdSequence* operator -> () { return _pd_seq; }
      inline const ComponentProcessIdSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator ComponentProcessIdSequence& () const { return *_pd_seq; }
#else
      inline operator const ComponentProcessIdSequence& () const { return *_pd_seq; }
      inline operator ComponentProcessIdSequence& () { return *_pd_seq; }
#endif
        
      inline const ComponentProcessIdSequence& in() const { return *_pd_seq; }
      inline ComponentProcessIdSequence&       inout()    { return *_pd_seq; }
      inline ComponentProcessIdSequence*&      out() {
        if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline ComponentProcessIdSequence* _retn() { ComponentProcessIdSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class ComponentProcessIdSequence_out;
      
    private:
      ComponentProcessIdSequence* _pd_seq;
    };

    class ComponentProcessIdSequence_out {
    public:
      inline ComponentProcessIdSequence_out(ComponentProcessIdSequence*& _s) : _data(_s) { _data = 0; }
      inline ComponentProcessIdSequence_out(ComponentProcessIdSequence_var& _s)
        : _data(_s._pd_seq) { _s = (ComponentProcessIdSequence*) 0; }
      inline ComponentProcessIdSequence_out(const ComponentProcessIdSequence_out& _s) : _data(_s._data) {}
      inline ComponentProcessIdSequence_out& operator = (const ComponentProcessIdSequence_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline ComponentProcessIdSequence_out& operator = (ComponentProcessIdSequence* _s) {
        _data = _s;
        return *this;
      }
      inline operator ComponentProcessIdSequence*&()  { return _data; }
      inline ComponentProcessIdSequence*& ptr()       { return _data; }
      inline ComponentProcessIdSequence* operator->() { return _data; }

      inline ComponentProcessIdType& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      ComponentProcessIdSequence*& _data;

    private:
      ComponentProcessIdSequence_out();
      ComponentProcessIdSequence_out& operator=(const ComponentProcessIdSequence_var&);
    };

    struct ComponentElementType {
      typedef _CORBA_ConstrType_Variable_Var<ComponentElementType> _var_type;

      
      ::CORBA::String_member componentId;

      ::CORBA::String_member elementId;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef ComponentElementType::_var_type ComponentElementType_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< ComponentElementType,ComponentElementType_var > ComponentElementType_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_ComponentElementType;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_ComponentElementSequence;

    class ComponentElementSequence_var;

    class ComponentElementSequence : public _CORBA_Unbounded_Sequence< ComponentElementType >  {
    public:
      typedef ComponentElementSequence_var _var_type;
      inline ComponentElementSequence() {}
      inline ComponentElementSequence(const ComponentElementSequence& _s)
        : _CORBA_Unbounded_Sequence< ComponentElementType > (_s) {}

      inline ComponentElementSequence(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence< ComponentElementType > (_max) {}
      inline ComponentElementSequence(_CORBA_ULong _max, _CORBA_ULong _len, ComponentElementType* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence< ComponentElementType > (_max, _len, _val, _rel) {}

    

      inline ComponentElementSequence& operator = (const ComponentElementSequence& _s) {
        _CORBA_Unbounded_Sequence< ComponentElementType > ::operator=(_s);
        return *this;
      }
    };

    class ComponentElementSequence_out;

    class ComponentElementSequence_var {
    public:
      inline ComponentElementSequence_var() : _pd_seq(0) {}
      inline ComponentElementSequence_var(ComponentElementSequence* _s) : _pd_seq(_s) {}
      inline ComponentElementSequence_var(const ComponentElementSequence_var& _s) {
        if (_s._pd_seq)  _pd_seq = new ComponentElementSequence(*_s._pd_seq);
        else             _pd_seq = 0;
      }
      inline ~ComponentElementSequence_var() { if (_pd_seq)  delete _pd_seq; }
        
      inline ComponentElementSequence_var& operator = (ComponentElementSequence* _s) {
        if (_pd_seq)  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline ComponentElementSequence_var& operator = (const ComponentElementSequence_var& _s) {
        if (&_s != this) {
          if (_s._pd_seq) {
            if (!_pd_seq)  _pd_seq = new ComponentElementSequence;
            *_pd_seq = *_s._pd_seq;
          }
          else if (_pd_seq) {
            delete _pd_seq;
            _pd_seq = 0;
          }
        }
        return *this;
      }
      inline ComponentElementType& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline ComponentElementSequence* operator -> () { return _pd_seq; }
      inline const ComponentElementSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator ComponentElementSequence& () const { return *_pd_seq; }
#else
      inline operator const ComponentElementSequence& () const { return *_pd_seq; }
      inline operator ComponentElementSequence& () { return *_pd_seq; }
#endif
        
      inline const ComponentElementSequence& in() const { return *_pd_seq; }
      inline ComponentElementSequence&       inout()    { return *_pd_seq; }
      inline ComponentElementSequence*&      out() {
        if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline ComponentElementSequence* _retn() { ComponentElementSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class ComponentElementSequence_out;
      
    private:
      ComponentElementSequence* _pd_seq;
    };

    class ComponentElementSequence_out {
    public:
      inline ComponentElementSequence_out(ComponentElementSequence*& _s) : _data(_s) { _data = 0; }
      inline ComponentElementSequence_out(ComponentElementSequence_var& _s)
        : _data(_s._pd_seq) { _s = (ComponentElementSequence*) 0; }
      inline ComponentElementSequence_out(const ComponentElementSequence_out& _s) : _data(_s._data) {}
      inline ComponentElementSequence_out& operator = (const ComponentElementSequence_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline ComponentElementSequence_out& operator = (ComponentElementSequence* _s) {
        _data = _s;
        return *this;
      }
      inline operator ComponentElementSequence*&()  { return _data; }
      inline ComponentElementSequence*& ptr()       { return _data; }
      inline ComponentElementSequence* operator->() { return _data; }

      inline ComponentElementType& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      ComponentElementSequence*& _data;

    private:
      ComponentElementSequence_out();
      ComponentElementSequence_out& operator=(const ComponentElementSequence_var&);
    };

  
  };

  class _objref_Application :
    public virtual _objref_Resource
  {
  public:
    // IDL operations
    Application::ComponentElementSequence* componentNamingContexts();
    Application::ComponentProcessIdSequence* componentProcessIds();
    DeviceAssignmentSequence* componentDevices();
    Application::ComponentElementSequence* componentImplementations();
    char* profile();
    char* name();

    // Constructors
    inline _objref_Application()  { _PR_setobj(0); }  // nil
    _objref_Application(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_Application();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_Application(const _objref_Application&);
    _objref_Application& operator = (const _objref_Application&);
    // not implemented

    friend class Application;
  };

  class _pof_Application : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_Application() : _OMNI_NS(proxyObjectFactory)(Application::_PD_repoId) {}
    virtual ~_pof_Application();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_Application :
    public virtual _impl_Resource
  {
  public:
    virtual ~_impl_Application();

    virtual Application::ComponentElementSequence* componentNamingContexts() = 0;
    virtual Application::ComponentProcessIdSequence* componentProcessIds() = 0;
    virtual DeviceAssignmentSequence* componentDevices() = 0;
    virtual Application::ComponentElementSequence* componentImplementations() = 0;
    virtual char* profile() = 0;
    virtual char* name() = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Application;

#ifndef __CF_mLoadableDevice__
#define __CF_mLoadableDevice__
  class LoadableDevice;
  class _objref_LoadableDevice;
  class _impl_LoadableDevice;
  
  typedef _objref_LoadableDevice* LoadableDevice_ptr;
  typedef LoadableDevice_ptr LoadableDeviceRef;

  class LoadableDevice_Helper {
  public:
    typedef LoadableDevice_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_LoadableDevice, LoadableDevice_Helper> LoadableDevice_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_LoadableDevice,LoadableDevice_Helper > LoadableDevice_out;

#endif

  // interface LoadableDevice
  class LoadableDevice {
  public:
    // Declarations for this interface type.
    typedef LoadableDevice_ptr _ptr_type;
    typedef LoadableDevice_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    enum LoadType { KERNEL_MODULE, DRIVER, SHARED_LIBRARY, EXECUTABLE /*, __max_LoadType=0xffffffff */ };
    typedef LoadType& LoadType_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_LoadType;

    class InvalidLoadKind : public ::CORBA::UserException {
    public:
      
      

      inline InvalidLoadKind() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      InvalidLoadKind(const InvalidLoadKind&);
      
      InvalidLoadKind& operator=(const InvalidLoadKind&);
      virtual ~InvalidLoadKind();
      virtual void _raise() const;
      static InvalidLoadKind* _downcast(::CORBA::Exception*);
      static const InvalidLoadKind* _downcast(const ::CORBA::Exception*);
      static inline InvalidLoadKind* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      inline void operator>>=(cdrStream&) const { }
      inline void operator<<=(cdrStream&) { }

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_InvalidLoadKind;

    class LoadFail : public ::CORBA::UserException {
    public:
      
      ErrorNumberType errorNumber;

      ::CORBA::String_member msg;

    

      inline LoadFail() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      LoadFail(const LoadFail&);
      LoadFail(ErrorNumberType i_errorNumber, const char* i_msg);
      LoadFail& operator=(const LoadFail&);
      virtual ~LoadFail();
      virtual void _raise() const;
      static LoadFail* _downcast(::CORBA::Exception*);
      static const LoadFail* _downcast(const ::CORBA::Exception*);
      static inline LoadFail* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      void operator>>=(cdrStream&) const ;
      void operator<<=(cdrStream&) ;

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_LoadFail;

  
  };

  class _objref_LoadableDevice :
    public virtual _objref_Device
  {
  public:
    // IDL operations
    void load(::CF::FileSystem_ptr fs, const char* fileName, ::CF::LoadableDevice::LoadType loadKind);
    void unload(const char* fileName);

    // Constructors
    inline _objref_LoadableDevice()  { _PR_setobj(0); }  // nil
    _objref_LoadableDevice(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_LoadableDevice();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_LoadableDevice(const _objref_LoadableDevice&);
    _objref_LoadableDevice& operator = (const _objref_LoadableDevice&);
    // not implemented

    friend class LoadableDevice;
  };

  class _pof_LoadableDevice : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_LoadableDevice() : _OMNI_NS(proxyObjectFactory)(LoadableDevice::_PD_repoId) {}
    virtual ~_pof_LoadableDevice();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_LoadableDevice :
    public virtual _impl_Device
  {
  public:
    virtual ~_impl_LoadableDevice();

    virtual void load(::CF::FileSystem_ptr fs, const char* fileName, ::CF::LoadableDevice::LoadType loadKind) = 0;
    virtual void unload(const char* fileName) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_LoadableDevice;

#ifndef __CF_mExecutableDevice__
#define __CF_mExecutableDevice__
  class ExecutableDevice;
  class _objref_ExecutableDevice;
  class _impl_ExecutableDevice;
  
  typedef _objref_ExecutableDevice* ExecutableDevice_ptr;
  typedef ExecutableDevice_ptr ExecutableDeviceRef;

  class ExecutableDevice_Helper {
  public:
    typedef ExecutableDevice_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_ExecutableDevice, ExecutableDevice_Helper> ExecutableDevice_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_ExecutableDevice,ExecutableDevice_Helper > ExecutableDevice_out;

#endif

  // interface ExecutableDevice
  class ExecutableDevice {
  public:
    // Declarations for this interface type.
    typedef ExecutableDevice_ptr _ptr_type;
    typedef ExecutableDevice_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    class InvalidProcess : public ::CORBA::UserException {
    public:
      
      ErrorNumberType errorNumber;

      ::CORBA::String_member msg;

    

      inline InvalidProcess() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      InvalidProcess(const InvalidProcess&);
      InvalidProcess(ErrorNumberType i_errorNumber, const char* i_msg);
      InvalidProcess& operator=(const InvalidProcess&);
      virtual ~InvalidProcess();
      virtual void _raise() const;
      static InvalidProcess* _downcast(::CORBA::Exception*);
      static const InvalidProcess* _downcast(const ::CORBA::Exception*);
      static inline InvalidProcess* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      void operator>>=(cdrStream&) const ;
      void operator<<=(cdrStream&) ;

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_InvalidProcess;

    class InvalidFunction : public ::CORBA::UserException {
    public:
      
      

      inline InvalidFunction() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      InvalidFunction(const InvalidFunction&);
      
      InvalidFunction& operator=(const InvalidFunction&);
      virtual ~InvalidFunction();
      virtual void _raise() const;
      static InvalidFunction* _downcast(::CORBA::Exception*);
      static const InvalidFunction* _downcast(const ::CORBA::Exception*);
      static inline InvalidFunction* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      inline void operator>>=(cdrStream&) const { }
      inline void operator<<=(cdrStream&) { }

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_InvalidFunction;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_ProcessID_Type;

    typedef ::CORBA::ULong ProcessID_Type;
    typedef ::CORBA::ULong_out ProcessID_Type_out;

    class InvalidParameters : public ::CORBA::UserException {
    public:
      
      Properties invalidParms;

    

      inline InvalidParameters() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      InvalidParameters(const InvalidParameters&);
      InvalidParameters(const Properties i_invalidParms);
      InvalidParameters& operator=(const InvalidParameters&);
      virtual ~InvalidParameters();
      virtual void _raise() const;
      static InvalidParameters* _downcast(::CORBA::Exception*);
      static const InvalidParameters* _downcast(const ::CORBA::Exception*);
      static inline InvalidParameters* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      void operator>>=(cdrStream&) const ;
      void operator<<=(cdrStream&) ;

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_InvalidParameters;

    class InvalidOptions : public ::CORBA::UserException {
    public:
      
      Properties invalidOpts;

    

      inline InvalidOptions() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      InvalidOptions(const InvalidOptions&);
      InvalidOptions(const Properties i_invalidOpts);
      InvalidOptions& operator=(const InvalidOptions&);
      virtual ~InvalidOptions();
      virtual void _raise() const;
      static InvalidOptions* _downcast(::CORBA::Exception*);
      static const InvalidOptions* _downcast(const ::CORBA::Exception*);
      static inline InvalidOptions* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      void operator>>=(cdrStream&) const ;
      void operator<<=(cdrStream&) ;

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_InvalidOptions;

    static _core_attr const char * STACK_SIZE;

    static _core_attr const char * PRIORITY_ID;

    class ExecuteFail : public ::CORBA::UserException {
    public:
      
      ErrorNumberType errorNumber;

      ::CORBA::String_member msg;

    

      inline ExecuteFail() {
        pd_insertToAnyFn    = insertToAnyFn;
        pd_insertToAnyFnNCP = insertToAnyFnNCP;
      }
      ExecuteFail(const ExecuteFail&);
      ExecuteFail(ErrorNumberType i_errorNumber, const char* i_msg);
      ExecuteFail& operator=(const ExecuteFail&);
      virtual ~ExecuteFail();
      virtual void _raise() const;
      static ExecuteFail* _downcast(::CORBA::Exception*);
      static const ExecuteFail* _downcast(const ::CORBA::Exception*);
      static inline ExecuteFail* _narrow(::CORBA::Exception* _e) {
        return _downcast(_e);
      }
      
      void operator>>=(cdrStream&) const ;
      void operator<<=(cdrStream&) ;

      static _core_attr insertExceptionToAny    insertToAnyFn;
      static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

      virtual ::CORBA::Exception* _NP_duplicate() const;

      static _core_attr const char* _PD_repoId;
      static _core_attr const char* _PD_typeId;

    private:
      virtual const char* _NP_typeId() const;
      virtual const char* _NP_repoId(int*) const;
      virtual void _NP_marshal(cdrStream&) const;
    };

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_ExecuteFail;

  
  };

  class _objref_ExecutableDevice :
    public virtual _objref_LoadableDevice
  {
  public:
    // IDL operations
    void terminate(::CF::ExecutableDevice::ProcessID_Type processId);
    ExecutableDevice::ProcessID_Type execute(const char* name, const ::CF::Properties& options, const ::CF::Properties& parameters);

    // Constructors
    inline _objref_ExecutableDevice()  { _PR_setobj(0); }  // nil
    _objref_ExecutableDevice(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_ExecutableDevice();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_ExecutableDevice(const _objref_ExecutableDevice&);
    _objref_ExecutableDevice& operator = (const _objref_ExecutableDevice&);
    // not implemented

    friend class ExecutableDevice;
  };

  class _pof_ExecutableDevice : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_ExecutableDevice() : _OMNI_NS(proxyObjectFactory)(ExecutableDevice::_PD_repoId) {}
    virtual ~_pof_ExecutableDevice();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_ExecutableDevice :
    public virtual _impl_LoadableDevice
  {
  public:
    virtual ~_impl_ExecutableDevice();

    virtual void terminate(::CF::ExecutableDevice::ProcessID_Type processId) = 0;
    virtual ExecutableDevice::ProcessID_Type execute(const char* name, const ::CF::Properties& options, const ::CF::Properties& parameters) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ExecutableDevice;

#ifndef __CF_mDeviceManager__
#define __CF_mDeviceManager__
  class DeviceManager;
  class _objref_DeviceManager;
  class _impl_DeviceManager;
  
  typedef _objref_DeviceManager* DeviceManager_ptr;
  typedef DeviceManager_ptr DeviceManagerRef;

  class DeviceManager_Helper {
  public:
    typedef DeviceManager_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_DeviceManager, DeviceManager_Helper> DeviceManager_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_DeviceManager,DeviceManager_Helper > DeviceManager_out;

#endif

  // interface DeviceManager
  class DeviceManager {
  public:
    // Declarations for this interface type.
    typedef DeviceManager_ptr _ptr_type;
    typedef DeviceManager_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    struct ServiceType {
      typedef _CORBA_ConstrType_Variable_Var<ServiceType> _var_type;

      
      ::CORBA::Object_Member serviceObject;

      ::CORBA::String_member serviceName;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef ServiceType::_var_type ServiceType_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< ServiceType,ServiceType_var > ServiceType_out;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_ServiceType;

    static _dyn_attr const ::CORBA::TypeCode_ptr _tc_ServiceSequence;

    class ServiceSequence_var;

    class ServiceSequence : public _CORBA_Unbounded_Sequence< ServiceType >  {
    public:
      typedef ServiceSequence_var _var_type;
      inline ServiceSequence() {}
      inline ServiceSequence(const ServiceSequence& _s)
        : _CORBA_Unbounded_Sequence< ServiceType > (_s) {}

      inline ServiceSequence(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence< ServiceType > (_max) {}
      inline ServiceSequence(_CORBA_ULong _max, _CORBA_ULong _len, ServiceType* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence< ServiceType > (_max, _len, _val, _rel) {}

    

      inline ServiceSequence& operator = (const ServiceSequence& _s) {
        _CORBA_Unbounded_Sequence< ServiceType > ::operator=(_s);
        return *this;
      }
    };

    class ServiceSequence_out;

    class ServiceSequence_var {
    public:
      inline ServiceSequence_var() : _pd_seq(0) {}
      inline ServiceSequence_var(ServiceSequence* _s) : _pd_seq(_s) {}
      inline ServiceSequence_var(const ServiceSequence_var& _s) {
        if (_s._pd_seq)  _pd_seq = new ServiceSequence(*_s._pd_seq);
        else             _pd_seq = 0;
      }
      inline ~ServiceSequence_var() { if (_pd_seq)  delete _pd_seq; }
        
      inline ServiceSequence_var& operator = (ServiceSequence* _s) {
        if (_pd_seq)  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline ServiceSequence_var& operator = (const ServiceSequence_var& _s) {
        if (&_s != this) {
          if (_s._pd_seq) {
            if (!_pd_seq)  _pd_seq = new ServiceSequence;
            *_pd_seq = *_s._pd_seq;
          }
          else if (_pd_seq) {
            delete _pd_seq;
            _pd_seq = 0;
          }
        }
        return *this;
      }
      inline ServiceType& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline ServiceSequence* operator -> () { return _pd_seq; }
      inline const ServiceSequence* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator ServiceSequence& () const { return *_pd_seq; }
#else
      inline operator const ServiceSequence& () const { return *_pd_seq; }
      inline operator ServiceSequence& () { return *_pd_seq; }
#endif
        
      inline const ServiceSequence& in() const { return *_pd_seq; }
      inline ServiceSequence&       inout()    { return *_pd_seq; }
      inline ServiceSequence*&      out() {
        if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline ServiceSequence* _retn() { ServiceSequence* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class ServiceSequence_out;
      
    private:
      ServiceSequence* _pd_seq;
    };

    class ServiceSequence_out {
    public:
      inline ServiceSequence_out(ServiceSequence*& _s) : _data(_s) { _data = 0; }
      inline ServiceSequence_out(ServiceSequence_var& _s)
        : _data(_s._pd_seq) { _s = (ServiceSequence*) 0; }
      inline ServiceSequence_out(const ServiceSequence_out& _s) : _data(_s._data) {}
      inline ServiceSequence_out& operator = (const ServiceSequence_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline ServiceSequence_out& operator = (ServiceSequence* _s) {
        _data = _s;
        return *this;
      }
      inline operator ServiceSequence*&()  { return _data; }
      inline ServiceSequence*& ptr()       { return _data; }
      inline ServiceSequence* operator->() { return _data; }

      inline ServiceType& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      ServiceSequence*& _data;

    private:
      ServiceSequence_out();
      ServiceSequence_out& operator=(const ServiceSequence_var&);
    };

  
  };

  class _objref_DeviceManager :
    public virtual _objref_PropertySet,
    public virtual _objref_PortSupplier
  {
  public:
    // IDL operations
    char* deviceConfigurationProfile();
    FileSystem_ptr fileSys();
    char* identifier();
    char* label();
    DeviceSequence* registeredDevices();
    DeviceManager::ServiceSequence* registeredServices();
    void registerDevice(::CF::Device_ptr registeringDevice);
    void unregisterDevice(::CF::Device_ptr registeredDevice);
    void shutdown();
    void registerService(::CORBA::Object_ptr registeringService, const char* name);
    void unregisterService(::CORBA::Object_ptr registeredService, const char* name);
    char* getComponentImplementationId(const char* componentInstantiationId);

    // Constructors
    inline _objref_DeviceManager()  { _PR_setobj(0); }  // nil
    _objref_DeviceManager(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_DeviceManager();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_DeviceManager(const _objref_DeviceManager&);
    _objref_DeviceManager& operator = (const _objref_DeviceManager&);
    // not implemented

    friend class DeviceManager;
  };

  class _pof_DeviceManager : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_DeviceManager() : _OMNI_NS(proxyObjectFactory)(DeviceManager::_PD_repoId) {}
    virtual ~_pof_DeviceManager();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_DeviceManager :
    public virtual _impl_PropertySet,
    public virtual _impl_PortSupplier
  {
  public:
    virtual ~_impl_DeviceManager();

    virtual char* deviceConfigurationProfile() = 0;
    virtual FileSystem_ptr fileSys() = 0;
    virtual char* identifier() = 0;
    virtual char* label() = 0;
    virtual DeviceSequence* registeredDevices() = 0;
    virtual DeviceManager::ServiceSequence* registeredServices() = 0;
    virtual void registerDevice(::CF::Device_ptr registeringDevice) = 0;
    virtual void unregisterDevice(::CF::Device_ptr registeredDevice) = 0;
    virtual void shutdown() = 0;
    virtual void registerService(::CORBA::Object_ptr registeringService, const char* name) = 0;
    virtual void unregisterService(::CORBA::Object_ptr registeredService, const char* name) = 0;
    virtual char* getComponentImplementationId(const char* componentInstantiationId) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_DeviceManager;

_CORBA_MODULE_END



_CORBA_MODULE POA_CF
_CORBA_MODULE_BEG

  class AggregateDevice :
    public virtual CF::_impl_AggregateDevice,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~AggregateDevice();

    inline ::CF::AggregateDevice_ptr _this() {
      return (::CF::AggregateDevice_ptr) _do_this(::CF::AggregateDevice::_PD_repoId);
    }
  };

  class FileSystem :
    public virtual CF::_impl_FileSystem,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~FileSystem();

    inline ::CF::FileSystem_ptr _this() {
      return (::CF::FileSystem_ptr) _do_this(::CF::FileSystem::_PD_repoId);
    }
  };

  class File :
    public virtual CF::_impl_File,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~File();

    inline ::CF::File_ptr _this() {
      return (::CF::File_ptr) _do_this(::CF::File::_PD_repoId);
    }
  };

  class ResourceFactory :
    public virtual CF::_impl_ResourceFactory,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~ResourceFactory();

    inline ::CF::ResourceFactory_ptr _this() {
      return (::CF::ResourceFactory_ptr) _do_this(::CF::ResourceFactory::_PD_repoId);
    }
  };

  class FileManager :
    public virtual CF::_impl_FileManager,
    public virtual FileSystem
  {
  public:
    virtual ~FileManager();

    inline ::CF::FileManager_ptr _this() {
      return (::CF::FileManager_ptr) _do_this(::CF::FileManager::_PD_repoId);
    }
  };

  class Port :
    public virtual CF::_impl_Port,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~Port();

    inline ::CF::Port_ptr _this() {
      return (::CF::Port_ptr) _do_this(::CF::Port::_PD_repoId);
    }
  };

  class LifeCycle :
    public virtual CF::_impl_LifeCycle,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~LifeCycle();

    inline ::CF::LifeCycle_ptr _this() {
      return (::CF::LifeCycle_ptr) _do_this(::CF::LifeCycle::_PD_repoId);
    }
  };

  class TestableObject :
    public virtual CF::_impl_TestableObject,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~TestableObject();

    inline ::CF::TestableObject_ptr _this() {
      return (::CF::TestableObject_ptr) _do_this(::CF::TestableObject::_PD_repoId);
    }
  };

  class PropertySet :
    public virtual CF::_impl_PropertySet,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~PropertySet();

    inline ::CF::PropertySet_ptr _this() {
      return (::CF::PropertySet_ptr) _do_this(::CF::PropertySet::_PD_repoId);
    }
  };

  class DomainManager :
    public virtual CF::_impl_DomainManager,
    public virtual PropertySet
  {
  public:
    virtual ~DomainManager();

    inline ::CF::DomainManager_ptr _this() {
      return (::CF::DomainManager_ptr) _do_this(::CF::DomainManager::_PD_repoId);
    }
  };

  class ApplicationFactory :
    public virtual CF::_impl_ApplicationFactory,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~ApplicationFactory();

    inline ::CF::ApplicationFactory_ptr _this() {
      return (::CF::ApplicationFactory_ptr) _do_this(::CF::ApplicationFactory::_PD_repoId);
    }
  };

  class PortSupplier :
    public virtual CF::_impl_PortSupplier,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~PortSupplier();

    inline ::CF::PortSupplier_ptr _this() {
      return (::CF::PortSupplier_ptr) _do_this(::CF::PortSupplier::_PD_repoId);
    }
  };

  class Resource :
    public virtual CF::_impl_Resource,
    public virtual LifeCycle,
      public virtual TestableObject,
      public virtual PropertySet,
      public virtual PortSupplier
  {
  public:
    virtual ~Resource();

    inline ::CF::Resource_ptr _this() {
      return (::CF::Resource_ptr) _do_this(::CF::Resource::_PD_repoId);
    }
  };

  class Device :
    public virtual CF::_impl_Device,
    public virtual Resource
  {
  public:
    virtual ~Device();

    inline ::CF::Device_ptr _this() {
      return (::CF::Device_ptr) _do_this(::CF::Device::_PD_repoId);
    }
  };

  class Application :
    public virtual CF::_impl_Application,
    public virtual Resource
  {
  public:
    virtual ~Application();

    inline ::CF::Application_ptr _this() {
      return (::CF::Application_ptr) _do_this(::CF::Application::_PD_repoId);
    }
  };

  class LoadableDevice :
    public virtual CF::_impl_LoadableDevice,
    public virtual Device
  {
  public:
    virtual ~LoadableDevice();

    inline ::CF::LoadableDevice_ptr _this() {
      return (::CF::LoadableDevice_ptr) _do_this(::CF::LoadableDevice::_PD_repoId);
    }
  };

  class ExecutableDevice :
    public virtual CF::_impl_ExecutableDevice,
    public virtual LoadableDevice
  {
  public:
    virtual ~ExecutableDevice();

    inline ::CF::ExecutableDevice_ptr _this() {
      return (::CF::ExecutableDevice_ptr) _do_this(::CF::ExecutableDevice::_PD_repoId);
    }
  };

  class DeviceManager :
    public virtual CF::_impl_DeviceManager,
    public virtual PropertySet,
      public virtual PortSupplier
  {
  public:
    virtual ~DeviceManager();

    inline ::CF::DeviceManager_ptr _this() {
      return (::CF::DeviceManager_ptr) _do_this(::CF::DeviceManager::_PD_repoId);
    }
  };

_CORBA_MODULE_END



_CORBA_MODULE OBV_CF
_CORBA_MODULE_BEG

_CORBA_MODULE_END





#undef _core_attr
#undef _dyn_attr

extern void operator<<=(::CORBA::Any& _a, const CF::DataType& _s);
extern void operator<<=(::CORBA::Any& _a, CF::DataType* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::DataType*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::DataType*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::InvalidProfile& _s);
void operator<<=(::CORBA::Any& _a, const CF::InvalidProfile* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::InvalidProfile*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::Properties& _s);
void operator<<=(::CORBA::Any& _a, CF::Properties* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::Properties*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::Properties*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::InvalidObjectReference& _s);
void operator<<=(::CORBA::Any& _a, const CF::InvalidObjectReference* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::InvalidObjectReference*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::OctetSequence& _s);
void operator<<=(::CORBA::Any& _a, CF::OctetSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::OctetSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::OctetSequence*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::StringSequence& _s);
void operator<<=(::CORBA::Any& _a, CF::StringSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::StringSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::StringSequence*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::UnknownProperties& _s);
void operator<<=(::CORBA::Any& _a, const CF::UnknownProperties* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::UnknownProperties*& _sp);

extern void operator<<=(::CORBA::Any& _a, const CF::DeviceAssignmentType& _s);
extern void operator<<=(::CORBA::Any& _a, CF::DeviceAssignmentType* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::DeviceAssignmentType*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::DeviceAssignmentType*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::DeviceAssignmentSequence& _s);
void operator<<=(::CORBA::Any& _a, CF::DeviceAssignmentSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::DeviceAssignmentSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::DeviceAssignmentSequence*& _sp);

inline void operator >>=(CF::ErrorNumberType _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (CF::ErrorNumberType& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= CF::CFEXDEV) {
    _e = (CF::ErrorNumberType) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, CF::ErrorNumberType _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::ErrorNumberType& _s);

void operator<<=(::CORBA::Any& _a, const CF::InvalidFileName& _s);
void operator<<=(::CORBA::Any& _a, const CF::InvalidFileName* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::InvalidFileName*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::FileException& _s);
void operator<<=(::CORBA::Any& _a, const CF::FileException* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::FileException*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::DeviceSequence& _s);
void operator<<=(::CORBA::Any& _a, CF::DeviceSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::DeviceSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::DeviceSequence*& _sp);

void operator<<=(::CORBA::Any& _a, CF::AggregateDevice_ptr _s);
void operator<<=(::CORBA::Any& _a, CF::AggregateDevice_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::AggregateDevice_ptr& _s);

void operator<<=(::CORBA::Any& _a, const CF::FileSystem::UnknownFileSystemProperties& _s);
void operator<<=(::CORBA::Any& _a, const CF::FileSystem::UnknownFileSystemProperties* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::FileSystem::UnknownFileSystemProperties*& _sp);

inline void operator >>=(CF::FileSystem::FileType _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (CF::FileSystem::FileType& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= CF::FileSystem::FILE_SYSTEM) {
    _e = (CF::FileSystem::FileType) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, CF::FileSystem::FileType _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::FileSystem::FileType& _s);

extern void operator<<=(::CORBA::Any& _a, const CF::FileSystem::FileInformationType& _s);
extern void operator<<=(::CORBA::Any& _a, CF::FileSystem::FileInformationType* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::FileSystem::FileInformationType*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::FileSystem::FileInformationType*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::FileSystem::FileInformationSequence& _s);
void operator<<=(::CORBA::Any& _a, CF::FileSystem::FileInformationSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::FileSystem::FileInformationSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::FileSystem::FileInformationSequence*& _sp);

void operator<<=(::CORBA::Any& _a, CF::FileSystem_ptr _s);
void operator<<=(::CORBA::Any& _a, CF::FileSystem_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::FileSystem_ptr& _s);

void operator<<=(::CORBA::Any& _a, const CF::File::IOException& _s);
void operator<<=(::CORBA::Any& _a, const CF::File::IOException* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::File::IOException*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::File::InvalidFilePointer& _s);
void operator<<=(::CORBA::Any& _a, const CF::File::InvalidFilePointer* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::File::InvalidFilePointer*& _sp);

void operator<<=(::CORBA::Any& _a, CF::File_ptr _s);
void operator<<=(::CORBA::Any& _a, CF::File_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::File_ptr& _s);

void operator<<=(::CORBA::Any& _a, const CF::ResourceFactory::InvalidResourceId& _s);
void operator<<=(::CORBA::Any& _a, const CF::ResourceFactory::InvalidResourceId* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::ResourceFactory::InvalidResourceId*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::ResourceFactory::ShutdownFailure& _s);
void operator<<=(::CORBA::Any& _a, const CF::ResourceFactory::ShutdownFailure* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::ResourceFactory::ShutdownFailure*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::ResourceFactory::CreateResourceFailure& _s);
void operator<<=(::CORBA::Any& _a, const CF::ResourceFactory::CreateResourceFailure* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::ResourceFactory::CreateResourceFailure*& _sp);

void operator<<=(::CORBA::Any& _a, CF::ResourceFactory_ptr _s);
void operator<<=(::CORBA::Any& _a, CF::ResourceFactory_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::ResourceFactory_ptr& _s);

extern void operator<<=(::CORBA::Any& _a, const CF::FileManager::MountType& _s);
extern void operator<<=(::CORBA::Any& _a, CF::FileManager::MountType* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::FileManager::MountType*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::FileManager::MountType*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::FileManager::MountSequence& _s);
void operator<<=(::CORBA::Any& _a, CF::FileManager::MountSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::FileManager::MountSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::FileManager::MountSequence*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::FileManager::NonExistentMount& _s);
void operator<<=(::CORBA::Any& _a, const CF::FileManager::NonExistentMount* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::FileManager::NonExistentMount*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::FileManager::InvalidFileSystem& _s);
void operator<<=(::CORBA::Any& _a, const CF::FileManager::InvalidFileSystem* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::FileManager::InvalidFileSystem*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::FileManager::MountPointAlreadyExists& _s);
void operator<<=(::CORBA::Any& _a, const CF::FileManager::MountPointAlreadyExists* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::FileManager::MountPointAlreadyExists*& _sp);

void operator<<=(::CORBA::Any& _a, CF::FileManager_ptr _s);
void operator<<=(::CORBA::Any& _a, CF::FileManager_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::FileManager_ptr& _s);

void operator<<=(::CORBA::Any& _a, const CF::Port::InvalidPort& _s);
void operator<<=(::CORBA::Any& _a, const CF::Port::InvalidPort* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::Port::InvalidPort*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::Port::OccupiedPort& _s);
void operator<<=(::CORBA::Any& _a, const CF::Port::OccupiedPort* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::Port::OccupiedPort*& _sp);

void operator<<=(::CORBA::Any& _a, CF::Port_ptr _s);
void operator<<=(::CORBA::Any& _a, CF::Port_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::Port_ptr& _s);

void operator<<=(::CORBA::Any& _a, const CF::LifeCycle::InitializeError& _s);
void operator<<=(::CORBA::Any& _a, const CF::LifeCycle::InitializeError* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::LifeCycle::InitializeError*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::LifeCycle::ReleaseError& _s);
void operator<<=(::CORBA::Any& _a, const CF::LifeCycle::ReleaseError* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::LifeCycle::ReleaseError*& _sp);

void operator<<=(::CORBA::Any& _a, CF::LifeCycle_ptr _s);
void operator<<=(::CORBA::Any& _a, CF::LifeCycle_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::LifeCycle_ptr& _s);

void operator<<=(::CORBA::Any& _a, const CF::TestableObject::UnknownTest& _s);
void operator<<=(::CORBA::Any& _a, const CF::TestableObject::UnknownTest* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::TestableObject::UnknownTest*& _sp);

void operator<<=(::CORBA::Any& _a, CF::TestableObject_ptr _s);
void operator<<=(::CORBA::Any& _a, CF::TestableObject_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::TestableObject_ptr& _s);

void operator<<=(::CORBA::Any& _a, const CF::PropertySet::InvalidConfiguration& _s);
void operator<<=(::CORBA::Any& _a, const CF::PropertySet::InvalidConfiguration* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::PropertySet::InvalidConfiguration*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::PropertySet::PartialConfiguration& _s);
void operator<<=(::CORBA::Any& _a, const CF::PropertySet::PartialConfiguration* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::PropertySet::PartialConfiguration*& _sp);

void operator<<=(::CORBA::Any& _a, CF::PropertySet_ptr _s);
void operator<<=(::CORBA::Any& _a, CF::PropertySet_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::PropertySet_ptr& _s);

void operator<<=(::CORBA::Any& _a, const CF::DomainManager::ApplicationInstallationError& _s);
void operator<<=(::CORBA::Any& _a, const CF::DomainManager::ApplicationInstallationError* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::DomainManager::ApplicationInstallationError*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::DomainManager::ApplicationSequence& _s);
void operator<<=(::CORBA::Any& _a, CF::DomainManager::ApplicationSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::DomainManager::ApplicationSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::DomainManager::ApplicationSequence*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::DomainManager::ApplicationFactorySequence& _s);
void operator<<=(::CORBA::Any& _a, CF::DomainManager::ApplicationFactorySequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::DomainManager::ApplicationFactorySequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::DomainManager::ApplicationFactorySequence*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::DomainManager::DeviceManagerSequence& _s);
void operator<<=(::CORBA::Any& _a, CF::DomainManager::DeviceManagerSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::DomainManager::DeviceManagerSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::DomainManager::DeviceManagerSequence*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::DomainManager::InvalidIdentifier& _s);
void operator<<=(::CORBA::Any& _a, const CF::DomainManager::InvalidIdentifier* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::DomainManager::InvalidIdentifier*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::DomainManager::DeviceManagerNotRegistered& _s);
void operator<<=(::CORBA::Any& _a, const CF::DomainManager::DeviceManagerNotRegistered* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::DomainManager::DeviceManagerNotRegistered*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::DomainManager::ApplicationUninstallationError& _s);
void operator<<=(::CORBA::Any& _a, const CF::DomainManager::ApplicationUninstallationError* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::DomainManager::ApplicationUninstallationError*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::DomainManager::RegisterError& _s);
void operator<<=(::CORBA::Any& _a, const CF::DomainManager::RegisterError* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::DomainManager::RegisterError*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::DomainManager::UnregisterError& _s);
void operator<<=(::CORBA::Any& _a, const CF::DomainManager::UnregisterError* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::DomainManager::UnregisterError*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::DomainManager::AlreadyConnected& _s);
void operator<<=(::CORBA::Any& _a, const CF::DomainManager::AlreadyConnected* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::DomainManager::AlreadyConnected*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::DomainManager::InvalidEventChannelName& _s);
void operator<<=(::CORBA::Any& _a, const CF::DomainManager::InvalidEventChannelName* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::DomainManager::InvalidEventChannelName*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::DomainManager::NotConnected& _s);
void operator<<=(::CORBA::Any& _a, const CF::DomainManager::NotConnected* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::DomainManager::NotConnected*& _sp);

void operator<<=(::CORBA::Any& _a, CF::DomainManager_ptr _s);
void operator<<=(::CORBA::Any& _a, CF::DomainManager_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::DomainManager_ptr& _s);

void operator<<=(::CORBA::Any& _a, const CF::ApplicationFactory::CreateApplicationRequestError& _s);
void operator<<=(::CORBA::Any& _a, const CF::ApplicationFactory::CreateApplicationRequestError* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::ApplicationFactory::CreateApplicationRequestError*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::ApplicationFactory::CreateApplicationError& _s);
void operator<<=(::CORBA::Any& _a, const CF::ApplicationFactory::CreateApplicationError* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::ApplicationFactory::CreateApplicationError*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::ApplicationFactory::InvalidInitConfiguration& _s);
void operator<<=(::CORBA::Any& _a, const CF::ApplicationFactory::InvalidInitConfiguration* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::ApplicationFactory::InvalidInitConfiguration*& _sp);

void operator<<=(::CORBA::Any& _a, CF::ApplicationFactory_ptr _s);
void operator<<=(::CORBA::Any& _a, CF::ApplicationFactory_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::ApplicationFactory_ptr& _s);

void operator<<=(::CORBA::Any& _a, const CF::PortSupplier::UnknownPort& _s);
void operator<<=(::CORBA::Any& _a, const CF::PortSupplier::UnknownPort* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::PortSupplier::UnknownPort*& _sp);

void operator<<=(::CORBA::Any& _a, CF::PortSupplier_ptr _s);
void operator<<=(::CORBA::Any& _a, CF::PortSupplier_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::PortSupplier_ptr& _s);

void operator<<=(::CORBA::Any& _a, const CF::Resource::StartError& _s);
void operator<<=(::CORBA::Any& _a, const CF::Resource::StartError* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::Resource::StartError*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::Resource::StopError& _s);
void operator<<=(::CORBA::Any& _a, const CF::Resource::StopError* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::Resource::StopError*& _sp);

void operator<<=(::CORBA::Any& _a, CF::Resource_ptr _s);
void operator<<=(::CORBA::Any& _a, CF::Resource_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::Resource_ptr& _s);

void operator<<=(::CORBA::Any& _a, const CF::Device::InvalidState& _s);
void operator<<=(::CORBA::Any& _a, const CF::Device::InvalidState* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::Device::InvalidState*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::Device::InvalidCapacity& _s);
void operator<<=(::CORBA::Any& _a, const CF::Device::InvalidCapacity* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::Device::InvalidCapacity*& _sp);

inline void operator >>=(CF::Device::AdminType _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (CF::Device::AdminType& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= CF::Device::UNLOCKED) {
    _e = (CF::Device::AdminType) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, CF::Device::AdminType _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::Device::AdminType& _s);

inline void operator >>=(CF::Device::OperationalType _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (CF::Device::OperationalType& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= CF::Device::DISABLED) {
    _e = (CF::Device::OperationalType) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, CF::Device::OperationalType _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::Device::OperationalType& _s);

inline void operator >>=(CF::Device::UsageType _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (CF::Device::UsageType& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= CF::Device::BUSY) {
    _e = (CF::Device::UsageType) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, CF::Device::UsageType _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::Device::UsageType& _s);

void operator<<=(::CORBA::Any& _a, CF::Device_ptr _s);
void operator<<=(::CORBA::Any& _a, CF::Device_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::Device_ptr& _s);

extern void operator<<=(::CORBA::Any& _a, const CF::Application::ComponentProcessIdType& _s);
extern void operator<<=(::CORBA::Any& _a, CF::Application::ComponentProcessIdType* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::Application::ComponentProcessIdType*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::Application::ComponentProcessIdType*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::Application::ComponentProcessIdSequence& _s);
void operator<<=(::CORBA::Any& _a, CF::Application::ComponentProcessIdSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::Application::ComponentProcessIdSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::Application::ComponentProcessIdSequence*& _sp);

extern void operator<<=(::CORBA::Any& _a, const CF::Application::ComponentElementType& _s);
extern void operator<<=(::CORBA::Any& _a, CF::Application::ComponentElementType* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::Application::ComponentElementType*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::Application::ComponentElementType*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::Application::ComponentElementSequence& _s);
void operator<<=(::CORBA::Any& _a, CF::Application::ComponentElementSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::Application::ComponentElementSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::Application::ComponentElementSequence*& _sp);

void operator<<=(::CORBA::Any& _a, CF::Application_ptr _s);
void operator<<=(::CORBA::Any& _a, CF::Application_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::Application_ptr& _s);

inline void operator >>=(CF::LoadableDevice::LoadType _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (CF::LoadableDevice::LoadType& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= CF::LoadableDevice::EXECUTABLE) {
    _e = (CF::LoadableDevice::LoadType) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, CF::LoadableDevice::LoadType _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::LoadableDevice::LoadType& _s);

void operator<<=(::CORBA::Any& _a, const CF::LoadableDevice::InvalidLoadKind& _s);
void operator<<=(::CORBA::Any& _a, const CF::LoadableDevice::InvalidLoadKind* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::LoadableDevice::InvalidLoadKind*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::LoadableDevice::LoadFail& _s);
void operator<<=(::CORBA::Any& _a, const CF::LoadableDevice::LoadFail* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::LoadableDevice::LoadFail*& _sp);

void operator<<=(::CORBA::Any& _a, CF::LoadableDevice_ptr _s);
void operator<<=(::CORBA::Any& _a, CF::LoadableDevice_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::LoadableDevice_ptr& _s);

void operator<<=(::CORBA::Any& _a, const CF::ExecutableDevice::InvalidProcess& _s);
void operator<<=(::CORBA::Any& _a, const CF::ExecutableDevice::InvalidProcess* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::ExecutableDevice::InvalidProcess*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::ExecutableDevice::InvalidFunction& _s);
void operator<<=(::CORBA::Any& _a, const CF::ExecutableDevice::InvalidFunction* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::ExecutableDevice::InvalidFunction*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::ExecutableDevice::InvalidParameters& _s);
void operator<<=(::CORBA::Any& _a, const CF::ExecutableDevice::InvalidParameters* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::ExecutableDevice::InvalidParameters*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::ExecutableDevice::InvalidOptions& _s);
void operator<<=(::CORBA::Any& _a, const CF::ExecutableDevice::InvalidOptions* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::ExecutableDevice::InvalidOptions*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::ExecutableDevice::ExecuteFail& _s);
void operator<<=(::CORBA::Any& _a, const CF::ExecutableDevice::ExecuteFail* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::ExecutableDevice::ExecuteFail*& _sp);

void operator<<=(::CORBA::Any& _a, CF::ExecutableDevice_ptr _s);
void operator<<=(::CORBA::Any& _a, CF::ExecutableDevice_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::ExecutableDevice_ptr& _s);

extern void operator<<=(::CORBA::Any& _a, const CF::DeviceManager::ServiceType& _s);
extern void operator<<=(::CORBA::Any& _a, CF::DeviceManager::ServiceType* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::DeviceManager::ServiceType*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::DeviceManager::ServiceType*& _sp);

void operator<<=(::CORBA::Any& _a, const CF::DeviceManager::ServiceSequence& _s);
void operator<<=(::CORBA::Any& _a, CF::DeviceManager::ServiceSequence* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::DeviceManager::ServiceSequence*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const CF::DeviceManager::ServiceSequence*& _sp);

void operator<<=(::CORBA::Any& _a, CF::DeviceManager_ptr _s);
void operator<<=(::CORBA::Any& _a, CF::DeviceManager_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, CF::DeviceManager_ptr& _s);



inline void
CF::AggregateDevice::_marshalObjRef(::CF::AggregateDevice_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CF::FileSystem::_marshalObjRef(::CF::FileSystem_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CF::File::_marshalObjRef(::CF::File_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CF::ResourceFactory::_marshalObjRef(::CF::ResourceFactory_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CF::FileManager::_marshalObjRef(::CF::FileManager_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CF::Port::_marshalObjRef(::CF::Port_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CF::LifeCycle::_marshalObjRef(::CF::LifeCycle_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CF::TestableObject::_marshalObjRef(::CF::TestableObject_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CF::PropertySet::_marshalObjRef(::CF::PropertySet_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CF::DomainManager::_marshalObjRef(::CF::DomainManager_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CF::ApplicationFactory::_marshalObjRef(::CF::ApplicationFactory_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CF::PortSupplier::_marshalObjRef(::CF::PortSupplier_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CF::Resource::_marshalObjRef(::CF::Resource_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CF::Device::_marshalObjRef(::CF::Device_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CF::Application::_marshalObjRef(::CF::Application_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CF::LoadableDevice::_marshalObjRef(::CF::LoadableDevice_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CF::ExecutableDevice::_marshalObjRef(::CF::ExecutableDevice_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
CF::DeviceManager::_marshalObjRef(::CF::DeviceManager_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}



#ifdef   USE_stub_in_nt_dll_NOT_DEFINED_cf
# undef  USE_stub_in_nt_dll
# undef  USE_stub_in_nt_dll_NOT_DEFINED_cf
#endif
#ifdef   USE_core_stub_in_nt_dll_NOT_DEFINED_cf
# undef  USE_core_stub_in_nt_dll
# undef  USE_core_stub_in_nt_dll_NOT_DEFINED_cf
#endif
#ifdef   USE_dyn_stub_in_nt_dll_NOT_DEFINED_cf
# undef  USE_dyn_stub_in_nt_dll
# undef  USE_dyn_stub_in_nt_dll_NOT_DEFINED_cf
#endif

#endif  // __cf_hh__

